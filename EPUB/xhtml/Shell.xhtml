<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- 这是 GNU Emacs 手册,
为 Emacs  29.2 更新

英文原版版权提示 - Original English version copyright note

Copyright © 1985-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "The GNU Manifesto," "Distribution" and
"GNU GENERAL PUBLIC LICENSE," with the Front-Cover Texts being "A GNU
Manual," and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."

中文翻译版版权提示 - Chinese translation revision copyright notice

版权所有 © 1985-2024 林羿轩(Ralph Lin).

您有在 Free Software Foundation发布的GNU Free Documentation License 第1.3版或之后版本的约束下对其进行再发布及修的权利。 恒定章节为 "The GNU Manifesto," "分发" "(中文版)GNU GENERAL PUBLIC LICENSE" 和
"GNU GENERAL PUBLIC LICENSE" , 前封面文字为 "A GNU
Manual,"后封面文字如下(a).  本书的FDL许可证可以在 "GNU Free Documentation
License."找到.

(a) FSF的后封面文字为: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."
 -->
<title>39 Running Shell Commands from Emacs (GNU Emacs Manual)</title>

<meta name="description" content="39 Running Shell Commands from Emacs (GNU Emacs Manual)"/>
<meta name="keywords" content="39 Running Shell Commands from Emacs (GNU Emacs Manual)"/>
<meta name="resource-type" content="document"/>
<meta name="distribution" content="global"/>
<meta name="Generator" content="texi2any"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>

<link href="emacs.xhtml" rel="start" title="Emacs 编辑器"/>
<link href="Key-Index.xhtml" rel="index" title="Key (Character) Index"/>
<link href="emacs.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="emacs.xhtml" rel="up" title="Emacs 编辑器"/>
<link href="Emacs-Server.xhtml#Emacs-Server" rel="next" title="40 Using Emacs as a Server"/>
<link href="Document-View.xhtml#Document-View" rel="prev" title="38 Document Viewing"/>
<style type="text/css">
<!--
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
kbd.key {font-style: normal}
-->
</style>


</head>

<body lang="zh_CN">
<div class="chapter-level-extent" id="Shell">

<h2 class="chapter section-level-set-chapter" id="Running-Shell-Commands-from-Emacs">39 Running Shell Commands from Emacs</h2>
<a class="index-entry-id" id="index-subshell"></a>
<a class="index-entry-id" id="index-shell-commands"></a>

<p>Emacs has commands for passing single command lines to shell
subprocesses, and for running a shell interactively with input and
output to an Emacs buffer, and for running a shell in a terminal
emulator window.
</p>
<dl class="table">
<dt><kbd class="kbd">M-! <var class="var">cmd</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Run the shell command <var class="var">cmd</var> and display the output
(<code class="code">shell-command</code>).
</p></dd>
<dt><kbd class="kbd">M-| <var class="var">cmd</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Run the shell command <var class="var">cmd</var> with region contents as input;
optionally replace the region with the output
(<code class="code">shell-command-on-region</code>).
</p></dd>
<dt><kbd class="kbd">M-&amp; <var class="var">cmd</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Run the shell command <var class="var">cmd</var> asynchronously, and display the output
(<code class="code">async-shell-command</code>).
</p></dd>
<dt><kbd class="kbd">M-x shell</kbd></dt>
<dd><p>Run a subshell with input and output through an Emacs buffer.  You can
then give commands interactively.
</p></dd>
<dt><kbd class="kbd">M-x term</kbd></dt>
<dd><p>Run a subshell with input and output through an Emacs buffer.  You can
then give commands interactively.  Full terminal emulation is
available.
</p></dd>
</dl>

<a class="index-entry-id" id="index-exec_002dpath"></a>
<p>Whenever you specify a relative file name for an executable program
(either in the <var class="var">cmd</var> argument to one of the above commands, or in
other contexts), Emacs searches for the program in the directories
specified by the variable <code class="code">exec-path</code>.  The value of this
variable must be a list of directories; the default value is
initialized from the environment variable <code class="env">PATH</code> when Emacs is
started (see <a class="pxref" href="Emacs-Invocation.xhtml#General-Variables">General Variables</a>).
</p>
<p><kbd class="kbd">M-x eshell</kbd> invokes a shell implemented entirely in Emacs.  It
is documented in its own manual.
See <a href="https://www.gnu.org/software/emacs/manual/html_node/eshell/index.html#Top">Eshell</a> in <cite class="cite">Eshell: The Emacs Shell</cite>.
</p>

<div class="section-level-extent" id="Single-Shell">
<h3 class="section subsection-level-set-section" id="Single-Shell-Commands">39.1 Single Shell Commands</h3>

<a class="index-entry-id" id="index-M_002d_0021"></a>
<a class="index-entry-id" id="index-shell_002dcommand"></a>
<a class="index-entry-id" id="index-shell_002dcommand_002dbuffer_002dname"></a>
<p><kbd class="kbd">M-!</kbd> (<code class="code">shell-command</code>) reads a line of text using the
minibuffer and executes it as a shell command, in a subshell made just
for that command.  Standard input for the command comes from the null
device.  If the shell command produces any output, the output appears
either in the echo area (if it is short), or in the &#8216;<samp class="samp">&quot;*Shell
Command Output*&quot;</samp>&#8217; (<code class="code">shell-command-buffer-name</code>) buffer (if the
output is long).  The variables <code class="code">resize-mini-windows</code> and
<code class="code">max-mini-window-height</code> (see <a class="pxref" href="Minibuffer.xhtml#Minibuffer-Edit">Editing in the Minibuffer</a>) control when
Emacs should consider the output to be too long for the echo area.
Note that customizing <code class="code">shell-command-dont-erase-buffer</code>,
described below, can affect what is displayed in the echo area.
</p>
<p>For instance, one way to decompress a file named <samp class="file">foo.gz</samp> is to
type <kbd class="kbd">M-! gunzip foo.gz <kbd class="key">RET</kbd></kbd>.  That shell command normally
creates the file <samp class="file">foo</samp> and produces no terminal output.
</p>
<p>A numeric argument to <code class="code">shell-command</code>, e.g., <kbd class="kbd">M-1 M-!</kbd>,
causes it to insert terminal output into the current buffer instead of
a separate buffer.  By default, it puts point before the output, and
sets the mark after the output (but a non-default value of
<code class="code">shell-command-dont-erase-buffer</code> can change that, see below).
For instance, <kbd class="kbd">M-1 M-! gunzip &lt; foo.gz <kbd class="key">RET</kbd></kbd> would insert the
uncompressed form of the file <samp class="file">foo.gz</samp> into the current buffer.
</p>
<p>Provided the specified shell command does not end with &#8216;<samp class="samp">&amp;</samp>&#8217;, it
runs <em class="dfn">synchronously</em>, and you must wait for it to exit before
continuing to use Emacs.  To stop waiting, type <kbd class="kbd">C-g</kbd> to quit;
this sends a <code class="code">SIGINT</code> signal to terminate the shell command (this
is the same signal that <kbd class="kbd">C-c</kbd> normally generates in the shell).
Emacs then waits until the command actually terminates.  If the shell
command doesn&#8217;t stop (because it ignores the <code class="code">SIGINT</code> signal),
type <kbd class="kbd">C-g</kbd> again; this sends the command a <code class="code">SIGKILL</code> signal,
which is impossible to ignore.
</p>
<a class="index-entry-id" id="index-M_002d_0026"></a>
<a class="index-entry-id" id="index-async_002dshell_002dcommand"></a>
<a class="index-entry-id" id="index-shell_002dcommand_002dbuffer_002dname_002dasync"></a>
<p>A shell command that ends in &#8216;<samp class="samp">&amp;</samp>&#8217; is executed
<em class="dfn">asynchronously</em>, and you can continue to use Emacs as it runs.
You can also type <kbd class="kbd">M-&amp;</kbd> (<code class="code">async-shell-command</code>) to execute a
shell command asynchronously; this is exactly like calling <kbd class="kbd">M-!</kbd>
with a trailing &#8216;<samp class="samp">&amp;</samp>&#8217;, except that you do not need the &#8216;<samp class="samp">&amp;</samp>&#8217;.
The output from asynchronous shell commands, by default, goes into the
&#8216;<samp class="samp">&quot;*Async Shell Command*&quot;</samp>&#8217; buffer
(<code class="code">shell-command-buffer-name-async</code>).  Emacs inserts the output
into this buffer as it comes in, whether or not the buffer is visible
in a window.
</p>
<a class="index-entry-id" id="index-async_002dshell_002dcommand_002dbuffer"></a>
<p>If you want to run more than one asynchronous shell command at the
same time, they could end up competing for the output buffer.  The
option <code class="code">async-shell-command-buffer</code> specifies what to do about
this; e.g., whether to rename the pre-existing output buffer, or to
use a different buffer for the new command.  Consult the variable&#8217;s
documentation for more possibilities.
</p>
<a class="index-entry-id" id="index-async_002dshell_002dcommand_002ddisplay_002dbuffer"></a>
<p>If you want the output buffer for asynchronous shell commands to be
displayed only when the command generates output, set
<code class="code">async-shell-command-display-buffer</code> to <code class="code">nil</code>.
</p>
<a class="index-entry-id" id="index-async_002dshell_002dcommand_002dwidth"></a>
<p>The option <code class="code">async-shell-command-width</code> defines the number of display
columns available for output of asynchronous shell commands.
A positive integer tells the shell to use that number of columns for
command output.  The default value is <code class="code">nil</code> that means to use
the same number of columns as provided by the shell.
</p>
<a class="index-entry-id" id="index-shell_002dcommand_002dprompt_002dshow_002dcwd"></a>
<p>To make the above commands show the current directory in their
prompts, customize the variable <code class="code">shell-command-prompt-show-cwd</code>
to a non-<code class="code">nil</code> value.
</p>
<a class="index-entry-id" id="index-M_002d_007c"></a>
<a class="index-entry-id" id="index-shell_002dcommand_002don_002dregion"></a>
<p><kbd class="kbd">M-|</kbd> (<code class="code">shell-command-on-region</code>) is like <kbd class="kbd">M-!</kbd>, but
passes the contents of the region as the standard input to the shell
command, instead of no input.  With a numeric argument, it deletes the
old region and replaces it with the output from the shell command.
</p>
<p>For example, you can use <kbd class="kbd">M-|</kbd> with the <code class="command">gpg</code> program to
see what keys are in the buffer.  If the buffer contains a GnuPG key,
type <kbd class="kbd">C-x h M-| gpg <kbd class="key">RET</kbd></kbd> to feed the entire buffer contents
to <code class="command">gpg</code>.  This will output the list of keys to the
buffer whose name is the value of <code class="code">shell-command-buffer-name</code>.
</p>
<a class="index-entry-id" id="index-shell_002dfile_002dname"></a>
<a class="index-entry-id" id="index-SHELL-environment-variable"></a>
<p>The above commands use the shell specified by the variable
<code class="code">shell-file-name</code>.  Its default value is determined by the
<code class="env">SHELL</code> environment variable when Emacs is started.  If the file
name is relative, Emacs searches the directories listed in
<code class="code">exec-path</code> (see <a class="pxref" href="#Shell">Running Shell Commands from Emacs</a>).
</p>
<p>If the default directory is remote (see <a class="pxref" href="Files.xhtml#Remote-Files">Remote Files</a>), the
default value is <samp class="file">/bin/sh</samp>.  This can be changed by declaring
<code class="code">shell-file-name</code> connection-local (see <a class="pxref" href="Customization.xhtml#Connection-Variables">Per-Connection Local Variables</a>).
</p>
<p>To specify a coding system for <kbd class="kbd">M-!</kbd> or <kbd class="kbd">M-|</kbd>, use the command
<kbd class="kbd">C-x <kbd class="key">RET</kbd> c</kbd> immediately beforehand.  See <a class="xref" href="International.xhtml#Communication-Coding">Coding Systems for Interprocess Communication</a>.
</p>
<a class="index-entry-id" id="index-shell_002dcommand_002ddefault_002derror_002dbuffer"></a>
<p>By default, error output is intermixed with the regular output in
the output buffer.  But if you change the value of the variable
<code class="code">shell-command-default-error-buffer</code> to a string, error output is
inserted into a buffer of that name.
</p>
<a class="index-entry-id" id="index-shell_002dcommand_002ddont_002derase_002dbuffer"></a>
<p>By default, the output buffer is erased between shell commands, except
when the output goes to the current buffer.  If you change the value
of the option <code class="code">shell-command-dont-erase-buffer</code> to <code class="code">erase</code>,
then the output buffer is always erased.  Other non-<code class="code">nil</code> values
prevent erasing of the output buffer, and&#8212;if the output buffer is
not the current buffer&#8212;also control where to put point after
inserting the output of the shell command:
</p>
<dl class="table">
<dt><code class="code">beg-last-out</code></dt>
<dd><p>Puts point at the beginning of the last shell-command output.
</p></dd>
<dt><code class="code">end-last-out</code></dt>
<dd><p>Puts point at the end of the last shell-command output, i.e. at the
end of the output buffer.
</p></dd>
<dt><code class="code">save-point</code></dt>
<dd><p>Restores the position of point as it was before inserting the
shell-command output.
</p></dd>
</dl>

<p>Note that if this option is non-<code class="code">nil</code>, the output shown in the
echo area could be from more than just the last command, since the
echo area just displays a portion of the output buffer.
</p>
<p>In case the output buffer is not the current buffer, shell command
output is appended at the end of this buffer.
</p>
</div>
<div class="section-level-extent" id="Interactive-Shell">
<h3 class="section subsection-level-set-section" id="Interactive-Subshell">39.2 Interactive Subshell</h3>

<a class="index-entry-id" id="index-shell"></a>
<p>To run a subshell interactively, type <kbd class="kbd">M-x shell</kbd>.  This creates
(or reuses) a buffer named <samp class="file">*shell*</samp>, and runs a shell subprocess
with input coming from and output going to that buffer.  That is to
say, any terminal output from the subshell goes into the buffer,
advancing point, and any terminal input for the subshell comes from
text in the buffer.  To give input to the subshell, go to the end of
the buffer and type the input, terminated by <kbd class="key">RET</kbd>.
</p>
<p>By default, when the subshell is invoked interactively, the
<samp class="file">*shell*</samp> buffer is displayed in a new window, unless the current
window already shows the <samp class="file">*shell*</samp> buffer.  This behavior can
be customized via <code class="code">display-buffer-alist</code> (see <a class="pxref" href="Windows.xhtml#Window-Choice">How <code class="code">display-buffer</code> works</a>).
</p>
<p>While the subshell is waiting or running a command, you can switch
windows or buffers and perform other editing in Emacs.  Emacs inserts
the output from the subshell into the Shell buffer whenever it has
time to process it (e.g., while waiting for keyboard input).
</p>
<a class="index-entry-id" id="index-comint_002dhighlight_002dinput-face"></a>
<a class="index-entry-id" id="index-comint_002dhighlight_002dprompt-face"></a>
<p>In the Shell buffer, prompts are displayed with the face
<code class="code">comint-highlight-prompt</code>, and submitted input lines are
displayed with the face <code class="code">comint-highlight-input</code>.  This makes it
easier to distinguish input lines from the shell output.
See <a class="xref" href="Display.xhtml#Faces">Text Faces</a>.
</p>
<p>To make multiple subshells, invoke <kbd class="kbd">M-x shell</kbd> with a prefix
argument (e.g., <kbd class="kbd">C-u M-x shell</kbd>).  Then the command will read a
buffer name, and create (or reuse) a subshell in that buffer.  You can
also rename the <samp class="file">*shell*</samp> buffer using <kbd class="kbd">M-x rename-uniquely</kbd>,
then create a new <samp class="file">*shell*</samp> buffer using plain <kbd class="kbd">M-x shell</kbd>.
Subshells in different buffers run independently and in parallel.
</p>
<p>Emacs attempts to keep track of what the current directory is by
looking at the commands you enter, looking for &#8216;<samp class="samp">cd</samp>&#8217; commands and
the like.  This is an error-prone solution, since there are many ways
to change the current directory, so Emacs also looks for special
<abbr class="acronym">OSC</abbr> (Operating System Commands) escape codes that are
designed to convey this information in a more reliable fashion.  You
should arrange for your shell to print the appropriate escape sequence
at each prompt, for instance with the following command:
</p>
<div class="example">
<pre class="example-preformatted">printf &quot;\e]7;file://%s%s\e\\&quot; &quot;$HOSTNAME&quot; &quot;$PWD&quot;
</pre></div>

<a class="index-entry-id" id="index-explicit_002dshell_002dfile_002dname"></a>
<a class="index-entry-id" id="index-environment-variables-for-subshells"></a>
<a class="index-entry-id" id="index-ESHELL-environment-variable"></a>
<p>To specify the shell file name used by <kbd class="kbd">M-x shell</kbd>, customize
the variable <code class="code">explicit-shell-file-name</code>.  If this is <code class="code">nil</code>
(the default), Emacs uses the environment variable <code class="env">ESHELL</code> if it
exists.  Otherwise, it usually uses the variable
<code class="code">shell-file-name</code> (see <a class="pxref" href="#Single-Shell">Single Shell Commands</a>); but if the default
directory is remote (see <a class="pxref" href="Files.xhtml#Remote-Files">Remote Files</a>), it prompts you for the
shell file name.  See <a class="xref" href="Minibuffer.xhtml#Minibuffer-File">Minibuffers for File Names</a>, for hints how to type remote
file names effectively.
</p>
<p>Emacs sends the new shell the contents of the file
<samp class="file">~/.emacs_<var class="var">shellname</var></samp> as input, if it exists, where
<var class="var">shellname</var> is the name of the file that the shell was loaded
from.  For example, if you use bash, the file sent to it is
<samp class="file">~/.emacs_bash</samp>.  If this file is not found, Emacs tries with
<samp class="file">~/.emacs.d/init_<var class="var">shellname</var>.sh</samp>.
</p>
<p>To specify a coding system for the shell, you can use the command
<kbd class="kbd">C-x <kbd class="key">RET</kbd> c</kbd> immediately before <kbd class="kbd">M-x shell</kbd>.  You can
also change the coding system for a running subshell by typing
<kbd class="kbd">C-x <kbd class="key">RET</kbd> p</kbd> in the shell buffer.  See <a class="xref" href="International.xhtml#Communication-Coding">Coding Systems for Interprocess Communication</a>.
</p>
<a class="index-entry-id" id="index-INSIDE_005fEMACS-environment-variable"></a>
<p>Emacs sets the environment variable <code class="env">INSIDE_EMACS</code> in the
subshell to &#8216;<samp class="samp"><var class="var">version</var>,comint</samp>&#8217;, where <var class="var">version</var> is the
Emacs version (e.g., &#8216;<samp class="samp">28.1</samp>&#8217;).  Programs can check this variable
to determine whether they are running inside an Emacs subshell.
</p>
</div>
<div class="section-level-extent" id="Shell-Mode">
<h3 class="section subsection-level-set-section" id="Shell-Mode-1">39.3 Shell Mode</h3>
<a class="index-entry-id" id="index-Shell-mode"></a>
<a class="index-entry-id" id="index-mode_002c-Shell"></a>

<p>The major mode for Shell buffers is Shell mode.  Many of its special
commands are bound to the <kbd class="kbd">C-c</kbd> prefix, and resemble the usual
editing and job control characters present in ordinary shells, except
that you must type <kbd class="kbd">C-c</kbd> first.  Here is a list of Shell mode
commands:
</p>
<dl class="table">
<dt><a class="index-entry-id" id="index-comint_002dsend_002dinput"></a>
<a id="index-RET-_0028Shell-mode_0029"></a><kbd class="kbd"><kbd class="key">RET</kbd></kbd></dt>
<dd><p>Send the current line as input to the subshell
(<code class="code">comint-send-input</code>).  Any shell prompt at the beginning of the
line is omitted (see <a class="pxref" href="#Shell-Prompts">Shell Prompts</a>).  If point is at the end of
buffer, this is like submitting the command line in an ordinary
interactive shell.  However, you can also invoke <kbd class="key">RET</kbd> elsewhere
in the shell buffer to submit the current line as input.
</p>
</dd>
<dt><a class="index-entry-id" id="index-completion_002dat_002dpoint_002c-in-Shell-Mode"></a>
<a class="index-entry-id" id="index-shell-completion"></a>
<a id="index-TAB-_0028Shell-mode_0029"></a><kbd class="kbd"><kbd class="key">TAB</kbd></kbd></dt>
<dd><p>Complete the command name or file name before point in the shell
buffer (<code class="code">completion-at-point</code>).  This uses the usual Emacs
completion rules (see <a class="pxref" href="Minibuffer.xhtml#Completion">Completion</a>), with the completion
alternatives being file names, environment variable names, the shell
command history, and history references (see <a class="pxref" href="#History-References">Shell History References</a>).
For options controlling the completion, see <a class="pxref" href="#Shell-Options">Shell Mode Options</a>.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002ddynamic_002dlist_002dfilename_2026"></a>
<a id="index-M_002d_003f-_0028Shell-mode_0029"></a><kbd class="kbd">M-?</kbd></dt>
<dd><p>Display temporarily a list of the possible completions of the file
name before point (<code class="code">comint-dynamic-list-filename-completions</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002ddelchar_002dor_002dmaybe_002deof"></a>
<a id="index-C_002dd-_0028Shell-mode_0029"></a><kbd class="kbd">C-d</kbd></dt>
<dd><p>Either delete a character or send <abbr class="acronym">EOF</abbr>
(<code class="code">comint-delchar-or-maybe-eof</code>).  Typed at the end of the shell
buffer, this sends <abbr class="acronym">EOF</abbr> to the subshell.  Typed at any other
position in the buffer, this deletes a character as usual.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dbol_002dor_002dprocess_002dmark"></a>
<a id="index-C_002dc-C_002da-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-a</kbd></dt>
<dd><p>Move to the beginning of the line, but after the prompt if any
(<code class="code">comint-bol-or-process-mark</code>).  If you repeat this command twice
in a row, the second time it moves back to the process mark, which is
the beginning of the input that you have not yet sent to the subshell.
(Normally that is the same place&#8212;the end of the prompt on this
line&#8212;but after <kbd class="kbd">C-c <kbd class="key">SPC</kbd></kbd> the process mark may be in a
previous line.)
</p>
</dd>
<dt><kbd class="kbd">C-c <kbd class="key">SPC</kbd></kbd></dt>
<dd><p>Accumulate multiple lines of input, then send them together
(<code class="code">comint-accumulate</code>).  This command inserts a newline before
point, but does not send the preceding text as input to the
subshell&#8212;at least, not yet.  Both lines, the one before this newline
and the one after, will be sent together (along with the newline that
separates them), when you type <kbd class="key">RET</kbd>.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dkill_002dinput"></a>
<a id="index-C_002dc-C_002du-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-u</kbd></dt>
<dd><p>Kill all text pending at end of buffer to be sent as input
(<code class="code">comint-kill-input</code>).  If point is not at end of buffer,
this only kills the part of this text that precedes point.
</p>
</dd>
<dt><a id="index-C_002dc-C_002dw-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-w</kbd></dt>
<dd><p>Kill a word before point (<code class="code">backward-kill-word</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dinterrupt_002dsubjob"></a>
<a id="index-C_002dc-C_002dc-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-c</kbd></dt>
<dd><p>Interrupt the shell or its current subjob if any
(<code class="code">comint-interrupt-subjob</code>).  This command also kills
any shell input pending in the shell buffer and not yet sent.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dstop_002dsubjob"></a>
<a id="index-C_002dc-C_002dz-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-z</kbd></dt>
<dd><p>Stop the shell or its current subjob if any (<code class="code">comint-stop-subjob</code>).
This command also kills any shell input pending in the shell buffer and
not yet sent.
</p>
</dd>
<dt><a class="index-entry-id" id="index-C_002dc-C_002d_005c-_0028Shell-mode_0029"></a>
<a id="index-comint_002dquit_002dsubjob"></a><kbd class="kbd">C-c C-\</kbd></dt>
<dd><p>Send quit signal to the shell or its current subjob if any
(<code class="code">comint-quit-subjob</code>).  This command also kills any shell input
pending in the shell buffer and not yet sent.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002ddelete_002doutput"></a>
<a id="index-C_002dc-C_002do-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-o</kbd></dt>
<dd><p>Delete the last batch of output from a shell command
(<code class="code">comint-delete-output</code>).  This is useful if a shell command spews
out lots of output that just gets in the way.  With a prefix argument,
this command saves the deleted text in the <code class="code">kill-ring</code>
(see <a class="pxref" href="Killing.xhtml#Kill-Ring">The Kill Ring</a>), so that you could later yank it (see <a class="pxref" href="Killing.xhtml#Yanking">Yanking</a>)
elsewhere.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dwrite_002doutput"></a>
<a id="index-C_002dc-C_002ds-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-s</kbd></dt>
<dd><p>Write the last batch of output from a shell command to a file
(<code class="code">comint-write-output</code>).  With a prefix argument, the file is
appended to instead.  Any prompt at the end of the output is not
written.
</p>
</dd>
<dt><a class="index-entry-id" id="index-C_002dM_002dl-_0028Shell-mode_0029"></a>
<a class="index-entry-id" id="index-comint_002dshow_002doutput"></a>
<a id="index-C_002dc-C_002dr-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-r</kbd></dt>
<dt><kbd class="kbd">C-M-l</kbd></dt>
<dd><p>Scroll to display the beginning of the last batch of output at the top
of the window; also move the cursor there (<code class="code">comint-show-output</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dshow_002dmaximum_002doutput"></a>
<a id="index-C_002dc-C_002de-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-e</kbd></dt>
<dd><p>Scroll to put the last line of the buffer at the bottom of the window
(<code class="code">comint-show-maximum-output</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-shell_002dforward_002dcommand"></a>
<a class="index-entry-id" id="index-shell_002dcommand_002dregexp"></a>
<a id="index-C_002dc-C_002df-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-f</kbd></dt>
<dd><p>Move forward across one shell command, but not beyond the current line
(<code class="code">shell-forward-command</code>).  The variable <code class="code">shell-command-regexp</code>
specifies how to recognize the end of a command.
</p>
</dd>
<dt><a class="index-entry-id" id="index-shell_002dbackward_002dcommand"></a>
<a id="index-C_002dc-C_002db-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-b</kbd></dt>
<dd><p>Move backward across one shell command, but not beyond the current line
(<code class="code">shell-backward-command</code>).
</p>
</dd>
<dt><kbd class="kbd">M-x dirs</kbd></dt>
<dd><p>Ask the shell for its working directory, and update the Shell buffer&#8217;s
default directory.  See <a class="xref" href="#Directory-Tracking">Directory Tracking</a>.
</p>
</dd>
<dt><a id="index-comint_002dsend_002dinvisible"></a><kbd class="kbd">M-x comint-send-invisible <kbd class="key">RET</kbd> <var class="var">text</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Send <var class="var">text</var> as input to the shell, after reading it without
echoing.  This is useful when a shell command runs a program that asks
for a password.
</p>
<p>Please note that Emacs will not echo passwords by default.  If you
really want them to be echoed, evaluate (see <a class="pxref" href="Building.xhtml#Lisp-Eval">Evaluating Emacs Lisp Expressions</a>) the
following Lisp expression:
</p>
<div class="example">
<pre class="example-preformatted">(remove-hook 'comint-output-filter-functions
             'comint-watch-for-password-prompt)
</pre></div>

</dd>
<dt><a id="index-comint_002dcontinue_002dsubjob"></a><kbd class="kbd">M-x comint-continue-subjob</kbd></dt>
<dd><p>Continue the shell process.  This is useful if you accidentally suspend
the shell process.<a class="footnote" id="DOCF21" href="#FOOT21"><sup>21</sup></a>
</p>
</dd>
<dt><a id="index-comint_002dstrip_002dctrl_002dm"></a><kbd class="kbd">M-x comint-strip-ctrl-m</kbd></dt>
<dd><p>Discard all control-M characters from the current group of shell output.
The most convenient way to use this command is to make it run
automatically when you get output from the subshell.  To do that,
evaluate this Lisp expression:
</p>
<div class="example">
<pre class="example-preformatted">(add-hook 'comint-output-filter-functions
          'comint-strip-ctrl-m)
</pre></div>

</dd>
<dt><a id="index-comint_002dtruncate_002dbuffer"></a><kbd class="kbd">M-x comint-truncate-buffer</kbd></dt>
<dd><p>This command truncates the shell buffer to a certain maximum number of
lines, specified by the variable <code class="code">comint-buffer-maximum-size</code>.
Here&#8217;s how to do this automatically each time you get output from the
subshell:
</p>
<div class="example">
<pre class="example-preformatted">(add-hook 'comint-output-filter-functions
          'comint-truncate-buffer)
</pre></div>
</dd>
</dl>

<p>By default, Shell mode handles common <abbr class="acronym">ANSI</abbr> escape codes (for
instance, for changing the color of text).  Emacs also optionally
supports some extend escape codes, like some of the <abbr class="acronym">OSC</abbr>
(Operating System Codes) if you put the following in your init file:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(add-hook 'comint-output-filter-functions 'comint-osc-process-output)
</pre></div>

<p>With this enabled, the output from, for instance, <code class="code">ls
--hyperlink</code> will be made into clickable buttons in the Shell mode
buffer.
</p>
<a class="index-entry-id" id="index-Comint-mode"></a>
<a class="index-entry-id" id="index-mode_002c-Comint"></a>
<p>Shell mode is a derivative of Comint mode, a general-purpose mode for
communicating with interactive subprocesses.  Most of the features of
Shell mode actually come from Comint mode, as you can see from the
command names listed above.  The special features of Shell mode include
the directory tracking feature, and a few user commands.
</p>
<p>Other Emacs features that use variants of Comint mode include GUD
(see <a class="pxref" href="Building.xhtml#Debuggers">Running Debuggers Under Emacs</a>) and <kbd class="kbd">M-x run-lisp</kbd> (see <a class="pxref" href="Building.xhtml#External-Lisp">Running an External Lisp</a>).
</p>
<a class="index-entry-id" id="index-comint_002drun"></a>
<p>You can use <kbd class="kbd">M-x comint-run</kbd> to execute any program of your choice
in a subprocess using unmodified Comint mode&#8212;without the
specializations of Shell mode.  To pass arguments to the program, use
<kbd class="kbd">C-u M-x comint-run</kbd>.
</p>
</div>
<div class="section-level-extent" id="Shell-Prompts">
<h3 class="section subsection-level-set-section" id="Shell-Prompts-1">39.4 Shell Prompts</h3>

<a class="index-entry-id" id="index-prompt_002c-shell"></a>
<p>A prompt is text output by a program to show that it is ready to
accept new user input.  Normally, Comint mode (and thus Shell mode)
automatically figures out which part of the buffer is a prompt, based
on the output of the subprocess.  (Specifically, it assumes that any
received output line which doesn&#8217;t end with a newline is a prompt.)
</p>
<p>Comint mode divides the buffer into two types of <em class="dfn">fields</em>: input
fields (where user input is typed) and output fields (everywhere
else).  Prompts are part of the output fields.  Most Emacs motion
commands do not cross field boundaries, unless they move over multiple
lines.  For instance, when point is in the input field on a shell
command line, <kbd class="kbd">C-a</kbd> puts point at the beginning of the input
field, after the prompt.  Internally, the fields are implemented using
the <code class="code">field</code> text property (see <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties">Text Properties</a> in <cite class="cite">the
Emacs Lisp Reference Manual</cite>).
</p>
<a class="index-entry-id" id="index-comint_002duse_002dprompt_002dregexp"></a>
<a class="index-entry-id" id="index-shell_002dprompt_002dpattern"></a>
<p>If you change the variable <code class="code">comint-use-prompt-regexp</code> to a
non-<code class="code">nil</code> value, then Comint mode will recognize prompts using a
regular expression (see <a class="pxref" href="Search.xhtml#Regexps">Syntax of Regular Expressions</a>).  In Shell mode, the regular
expression is specified by the variable <code class="code">shell-prompt-pattern</code>.
The default value of <code class="code">comint-use-prompt-regexp</code> is <code class="code">nil</code>,
because this method for recognizing prompts is unreliable, but you may
want to set it to a non-<code class="code">nil</code> value in unusual circumstances.  In
that case, Emacs does not divide the Comint buffer into fields, so the
general motion commands behave as they normally do in buffers without
special text properties.  However, you can use the paragraph motion
commands to conveniently navigate the buffer (see <a class="pxref" href="Text.xhtml#Paragraphs">Paragraphs</a>); in
Shell mode, Emacs uses <code class="code">shell-prompt-pattern</code> as paragraph
boundaries.
</p>
</div>
<div class="section-level-extent" id="Shell-History">
<h3 class="section subsection-level-set-section" id="Shell-Command-History">39.5 Shell Command History</h3>

<p>Shell buffers support three ways of repeating earlier commands.  You
can use keys like those used for the minibuffer history; these work
much as they do in the minibuffer, inserting text from prior commands
while point remains always at the end of the buffer.  You can move
through the buffer to previous inputs in their original place, then
resubmit them or copy them to the end.  Or you can use a
&#8216;<samp class="samp">!</samp>&#8217;-style history reference.
</p>

<div class="subsection-level-extent" id="Shell-Ring">
<h4 class="subsection subsubsection-level-set-subsection" id="Shell-History-Ring">39.5.1 Shell History Ring</h4>

<dl class="table">
<dt><a class="index-entry-id" id="index-M_002dp-_0028Shell-mode_0029"></a>
<a id="index-comint_002dprevious_002dinput"></a><kbd class="kbd">M-p</kbd></dt>
<dt><kbd class="kbd">C-<kbd class="key">UP</kbd></kbd></dt>
<dd><p>Fetch the next earlier old shell command
(<code class="code">comint-previous-input</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dnext_002dinput"></a>
<a id="index-M_002dn-_0028Shell-mode_0029"></a><kbd class="kbd">M-n</kbd></dt>
<dt><kbd class="kbd">C-<kbd class="key">DOWN</kbd></kbd></dt>
<dd><p>Fetch the next later old shell command (<code class="code">comint-next-input</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dhistory_002disearch_002dbackward_002dregexp"></a>
<a id="index-M_002dr-_0028Shell-mode_0029"></a><kbd class="kbd">M-r</kbd></dt>
<dd><p>Begin an incremental regexp search of old shell commands
(<code class="code">comint-history-isearch-backward-regexp</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dget_002dnext_002dfrom_002dhistory"></a>
<a id="index-C_002dc-C_002dx-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-x</kbd></dt>
<dd><p>Fetch the next subsequent command from the history
(<code class="code">comint-get-next-from-history</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dinsert_002dprevious_002dargument"></a>
<a id="index-C_002dc-_002e-_0028Shell-mode_0029"></a><kbd class="kbd">C-c .</kbd></dt>
<dd><p>Fetch one argument from an old shell command
(<code class="code">comint-input-previous-argument</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002ddynamic_002dlist_002dinput_002dring"></a>
<a id="index-C_002dc-C_002dl-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-l</kbd></dt>
<dd><p>Display the buffer&#8217;s history of shell commands in another window
(<code class="code">comint-dynamic-list-input-ring</code>).
</p></dd>
</dl>

<p>Shell buffers provide a history of previously entered shell
commands.  To reuse shell commands from the history, use the editing
commands <kbd class="kbd">M-p</kbd>, <kbd class="kbd">M-n</kbd>, and <kbd class="kbd">M-r</kbd>.  These work
similar to the minibuffer history commands (see <a class="pxref" href="Minibuffer.xhtml#Minibuffer-History">Minibuffer History</a>), except that they operate within the Shell buffer rather
than the minibuffer, and <code class="code">M-r</code> in a Shell buffer invokes
incremental search through shell command history.
</p>
<p><kbd class="kbd">M-p</kbd> fetches an earlier shell command to the end of the shell
buffer.  Successive use of <kbd class="kbd">M-p</kbd> fetches successively earlier
shell commands, each replacing any text that was already present as
potential shell input.  <kbd class="kbd">M-n</kbd> does likewise except that it finds
successively more recent shell commands from the buffer.
<kbd class="kbd">C-<kbd class="key">UP</kbd></kbd> works like <kbd class="kbd">M-p</kbd>, and <kbd class="kbd">C-<kbd class="key">DOWN</kbd></kbd> like
<kbd class="kbd">M-n</kbd>.
</p>
<p>The history search command <kbd class="kbd">M-r</kbd> begins an incremental regular
expression search of previous shell commands.  After typing <kbd class="kbd">M-r</kbd>,
start typing the desired string or regular expression; the last
matching shell command will be displayed in the current line.
Incremental search commands have their usual effects&#8212;for instance,
<kbd class="kbd">C-s</kbd> and <kbd class="kbd">C-r</kbd> search forward and backward for the next match
(see <a class="pxref" href="Search.xhtml#Incremental-Search">Incremental Search</a>).  When you find the desired input, type
<kbd class="key">RET</kbd> to terminate the search.  This puts the input in the command
line.  Any partial input you were composing before navigating the
history list is restored when you go to the beginning or end of the
history ring.
</p>
<p>Often it is useful to reexecute several successive shell commands that
were previously executed in sequence.  To do this, first find and
reexecute the first command of the sequence.  Then type <kbd class="kbd">C-c C-x</kbd>;
that will fetch the following command&#8212;the one that follows the command
you just repeated.  Then type <kbd class="key">RET</kbd> to reexecute this command.  You
can reexecute several successive commands by typing <kbd class="kbd">C-c C-x
<kbd class="key">RET</kbd></kbd> over and over.
</p>
<p>The command <kbd class="kbd">C-c .</kbd> (<code class="code">comint-insert-previous-argument</code>)
copies an individual argument from a previous command, like
<kbd class="kbd"><kbd class="key">ESC</kbd> .</kbd> in Bash and <code class="command">zsh</code>.  The simplest use
copies the last argument from the previous shell command.  With a
prefix argument <var class="var">n</var>, it copies the <var class="var">n</var>th argument instead.
Repeating <kbd class="kbd">C-c .</kbd> copies from an earlier shell commands, always
using the same value of <var class="var">n</var>  (don&#8217;t give a prefix argument when
you repeat the <kbd class="kbd">C-c .</kbd> command).
</p>
<a class="index-entry-id" id="index-comint_002dinsert_002dprevious_002dargument_002dfrom_002dend"></a>
<p>If you set <code class="code">comint-insert-previous-argument-from-end</code> to a
non-<code class="code">nil</code> value, <kbd class="kbd">C-c .</kbd> will instead copy the <var class="var">n</var>th
argument counting from the last one; this emulates <kbd class="kbd"><kbd class="key">ESC</kbd> .</kbd>
in <code class="command">zsh</code>.
</p>
<p>These commands get the text of previous shell commands from a special
history list, not from the shell buffer itself.  Thus, editing the shell
buffer, or even killing large parts of it, does not affect the history
that these commands access.
</p>
<a class="index-entry-id" id="index-comint_002dinput_002dring_002dfile_002dname"></a>
<p>Some shells store their command histories in files so that you can
refer to commands from previous shell sessions.  Emacs reads
the command history file for your chosen shell, to initialize its own
command history.  The file name is <samp class="file">~/.bash_history</samp> for bash,
<samp class="file">~/.sh_history</samp> for ksh, and <samp class="file">~/.history</samp> for other shells.
</p>
<a class="index-entry-id" id="index-tramp_002dhistfile_002doverride"></a>
<p>If you run the shell on a remote host, this setting might be
overwritten by the variable <code class="code">tramp-histfile-override</code>.  It is
recommended to set this variable to <code class="code">nil</code>.
</p>
</div>
<div class="subsection-level-extent" id="Shell-History-Copying">
<h4 class="subsection subsubsection-level-set-subsection" id="Shell-History-Copying-1">39.5.2 Shell History Copying</h4>

<dl class="table">
<dt><a class="index-entry-id" id="index-comint_002dprevious_002dprompt"></a>
<a id="index-C_002dc-C_002dp-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-p</kbd></dt>
<dd><p>Move point to the previous prompt (<code class="code">comint-previous-prompt</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dnext_002dprompt"></a>
<a id="index-C_002dc-C_002dn-_0028Shell-mode_0029"></a><kbd class="kbd">C-c C-n</kbd></dt>
<dd><p>Move point to the following prompt (<code class="code">comint-next-prompt</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dcopy_002dold_002dinput"></a>
<a id="index-C_002dc-RET-_0028Shell-mode_0029"></a><kbd class="kbd">C-c <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Copy the input command at point, inserting the copy at the end of the
buffer (<code class="code">comint-copy-old-input</code>).  This is useful if you move
point back to a previous command.  After you copy the command, you can
submit the copy as input with <kbd class="key">RET</kbd>.  If you wish, you can edit
the copy before resubmitting it.  If you use this command on an output
line, it copies that line to the end of the buffer.
</p>
</dd>
<dt><kbd class="kbd">mouse-2</kbd></dt>
<dd><p>If <code class="code">comint-use-prompt-regexp</code> is <code class="code">nil</code> (the default), copy
the old input command that you click on, inserting the copy at the end
of the buffer (<code class="code">comint-insert-input</code>).  If
<code class="code">comint-use-prompt-regexp</code> is non-<code class="code">nil</code>, or if the click is
not over old input, just yank as usual.
</p></dd>
</dl>

<p>Moving to a previous input and then copying it with <kbd class="kbd">C-c
<kbd class="key">RET</kbd></kbd> or <kbd class="kbd">mouse-2</kbd> produces the same results&#8212;the same
buffer contents&#8212;that you would get by using <kbd class="kbd">M-p</kbd> enough times
to fetch that previous input from the history list.  However, <kbd class="kbd">C-c
<kbd class="key">RET</kbd></kbd> copies the text from the buffer, which can be different
from what is in the history list if you edit the input text in the
buffer after it has been sent.
</p>
</div>
<div class="subsection-level-extent" id="History-References">
<h4 class="subsection subsubsection-level-set-subsection" id="Shell-History-References">39.5.3 Shell History References</h4>
<a class="index-entry-id" id="index-history-reference"></a>

<p>Various shells, including csh and bash, support <em class="dfn">history
references</em> that begin with &#8216;<samp class="samp">!</samp>&#8217; and &#8216;<samp class="samp">^</samp>&#8217;.  Shell mode
recognizes these constructs, and can perform the history substitution
for you.
</p>
<p>If you insert a history reference and type <kbd class="key">TAB</kbd>, this searches
the input history for a matching command, performs substitution if
necessary, and places the result in the buffer in place of the history
reference.  For example, you can fetch the most recent command
beginning with &#8216;<samp class="samp">mv</samp>&#8217; with <kbd class="kbd">! m v <kbd class="key">TAB</kbd></kbd>.  You can edit the
command if you wish, and then resubmit the command to the shell by
typing <kbd class="key">RET</kbd>.
</p>
<a class="index-entry-id" id="index-comint_002dinput_002dautoexpand"></a>
<a class="index-entry-id" id="index-comint_002dmagic_002dspace"></a>
<p>Shell mode can optionally expand history references in the buffer
when you send them to the shell.  To request this, set the variable
<code class="code">comint-input-autoexpand</code> to <code class="code">input</code>.  You can make
<kbd class="key">SPC</kbd> perform history expansion by binding <kbd class="key">SPC</kbd> to the
command <code class="code">comint-magic-space</code>.  See <a class="xref" href="Customization.xhtml#Rebinding">Changing Key Bindings Interactively</a>.
</p>
<p>Shell mode recognizes history references when they follow a prompt.
See <a class="xref" href="#Shell-Prompts">Shell Prompts</a>, for how Shell mode recognizes prompts.
</p>
</div>
</div>
<div class="section-level-extent" id="Directory-Tracking">
<h3 class="section subsection-level-set-section" id="Directory-Tracking-1">39.6 Directory Tracking</h3>
<a class="index-entry-id" id="index-directory-tracking"></a>

<a class="index-entry-id" id="index-shell_002dpushd_002dregexp"></a>
<a class="index-entry-id" id="index-shell_002dpopd_002dregexp"></a>
<a class="index-entry-id" id="index-shell_002dcd_002dregexp"></a>
<p>Shell mode keeps track of &#8216;<samp class="samp">cd</samp>&#8217;, &#8216;<samp class="samp">pushd</samp>&#8217; and &#8216;<samp class="samp">popd</samp>&#8217;
commands given to the subshell, in order to keep the Shell buffer&#8217;s
default directory (see <a class="pxref" href="Files.xhtml#File-Names">File Names</a>) the same as the shell&#8217;s working
directory.  It recognizes these commands by examining lines of input
that you send.
</p>
<p>If you use aliases for these commands, you can tell Emacs to
recognize them also, by setting the variables
<code class="code">shell-pushd-regexp</code>, <code class="code">shell-popd-regexp</code>, and
<code class="code">shell-cd-regexp</code> to the appropriate regular expressions
(see <a class="pxref" href="Search.xhtml#Regexps">Syntax of Regular Expressions</a>).  For example, if <code class="code">shell-pushd-regexp</code> matches
the beginning of a shell command line, that line is regarded as a
<code class="code">pushd</code> command.  These commands are recognized only at the
beginning of a shell command line.
</p>
<a class="index-entry-id" id="index-dirs"></a>
<p>If Emacs gets confused about changes in the working directory of the
subshell, type <kbd class="kbd">M-x dirs</kbd>.  This command asks the shell for its
working directory and updates the default directory accordingly.  It
works for shells that support the most common command syntax, but may
not work for unusual shells.
</p>
<a class="index-entry-id" id="index-dirtrack_002dmode"></a>
<a class="index-entry-id" id="index-Dirtrack-mode"></a>
<a class="index-entry-id" id="index-mode_002c-Dirtrack"></a>
<a class="index-entry-id" id="index-dirtrack_002dlist"></a>
<p>You can also use Dirtrack mode, a buffer-local minor mode that
implements an alternative method of tracking the shell&#8217;s working
directory.  To use this method, your shell prompt must contain the
working directory at all times, and you must supply a regular
expression for recognizing which part of the prompt contains the
working directory; see the documentation of the variable
<code class="code">dirtrack-list</code> for details.  To use Dirtrack mode, type <kbd class="kbd">M-x
dirtrack-mode</kbd> in the Shell buffer, or add <code class="code">dirtrack-mode</code> to
<code class="code">shell-mode-hook</code> (see <a class="pxref" href="Customization.xhtml#Hooks">Hooks</a>).
</p>
</div>
<div class="section-level-extent" id="Shell-Options">
<h3 class="section subsection-level-set-section" id="Shell-Mode-Options">39.7 Shell Mode Options</h3>

<a class="index-entry-id" id="index-comint_002dscroll_002dto_002dbottom_002don_002dinput"></a>
<p>If the variable <code class="code">comint-scroll-to-bottom-on-input</code> is
non-<code class="code">nil</code>, insertion and yank commands scroll the selected window
to the bottom before inserting.  The default is <code class="code">nil</code>.
</p>
<a class="index-entry-id" id="index-comint_002dscroll_002dshow_002dmaximum_002doutput"></a>
<p>If <code class="code">comint-scroll-show-maximum-output</code> is non-<code class="code">nil</code>, then
arrival of output when point is at the end tries to scroll the last
line of text to the bottom line of the window, showing as much useful
text as possible.  (This mimics the scrolling behavior of most
terminals.)  The default is <code class="code">t</code>.
</p>
<a class="index-entry-id" id="index-comint_002dmove_002dpoint_002dfor_002doutput"></a>
<p>By setting <code class="code">comint-move-point-for-output</code>, you can opt for
having point jump to the end of the buffer whenever output arrives&#8212;no
matter where in the buffer point was before.  If the value is
<code class="code">this</code>, point jumps in the selected window.  If the value is
<code class="code">all</code>, point jumps in each window that shows the Comint buffer.  If
the value is <code class="code">other</code>, point jumps in all nonselected windows that
show the current buffer.  The default value is <code class="code">nil</code>, which means
point does not jump to the end.
</p>
<a class="index-entry-id" id="index-comint_002dprompt_002dread_002donly"></a>
<p>If you set <code class="code">comint-prompt-read-only</code>, the prompts in the Comint
buffer are read-only.
</p>
<a class="index-entry-id" id="index-comint_002dinput_002dignoredups"></a>
<p>The variable <code class="code">comint-input-ignoredups</code> controls whether successive
identical inputs are stored in the input history.  A non-<code class="code">nil</code>
value means to omit an input that is the same as the previous input.
The default is <code class="code">nil</code>, which means to store each input even if it is
equal to the previous input.
</p>
<a class="index-entry-id" id="index-comint_002dcompletion_002daddsuffix"></a>
<a class="index-entry-id" id="index-comint_002dcompletion_002drecexact"></a>
<a class="index-entry-id" id="index-comint_002dcompletion_002dautolist"></a>
<p>Three variables customize file name completion.  The variable
<code class="code">comint-completion-addsuffix</code> controls whether completion inserts a
space or a slash to indicate a fully completed file or directory name
(non-<code class="code">nil</code> means do insert a space or slash).
<code class="code">comint-completion-recexact</code>, if non-<code class="code">nil</code>, directs <kbd class="key">TAB</kbd>
to choose the shortest possible completion if the usual Emacs completion
algorithm cannot add even a single character.
<code class="code">comint-completion-autolist</code>, if non-<code class="code">nil</code>, says to list all
the possible completions whenever completion is not exact.
</p>
<a class="index-entry-id" id="index-shell_002dcompletion_002dexeconly"></a>
<p>Command completion normally considers only executable files.
If you set <code class="code">shell-completion-execonly</code> to <code class="code">nil</code>,
it considers nonexecutable files as well.
</p>
<a class="index-entry-id" id="index-shell_002dcompletion_002dfignore"></a>
<a class="index-entry-id" id="index-comint_002dcompletion_002dfignore"></a>
<p>The variable <code class="code">shell-completion-fignore</code> specifies a list of file
name extensions to ignore in Shell mode completion.  The default
setting is <code class="code">nil</code>, but some users prefer <code class="code">(&quot;~&quot; &quot;#&quot; &quot;%&quot;)</code> to
ignore file names ending in &#8216;<samp class="samp">~</samp>&#8217;, &#8216;<samp class="samp">#</samp>&#8217; or &#8216;<samp class="samp">%</samp>&#8217;.  Other
related Comint modes use the variable <code class="code">comint-completion-fignore</code>
instead.
</p>
<a class="index-entry-id" id="index-shell_002ddynamic_002dcomplete_002dcommand"></a>
<p>Some implementation details of the shell command completion may also be found
in the lisp documentation of the <code class="code">shell-dynamic-complete-command</code>
function.
</p>
<a class="index-entry-id" id="index-shell_002dpushd_002dtohome"></a>
<a class="index-entry-id" id="index-shell_002dpushd_002ddextract"></a>
<a class="index-entry-id" id="index-shell_002dpushd_002ddunique"></a>
<p>You can configure the behavior of &#8216;<samp class="samp">pushd</samp>&#8217;.  Variables control
whether &#8216;<samp class="samp">pushd</samp>&#8217; behaves like &#8216;<samp class="samp">cd</samp>&#8217; if no argument is given
(<code class="code">shell-pushd-tohome</code>), pop rather than rotate with a numeric
argument (<code class="code">shell-pushd-dextract</code>), and only add directories to the
directory stack if they are not already on it
(<code class="code">shell-pushd-dunique</code>).  The values you choose should match the
underlying shell, of course.
</p>
<a class="index-entry-id" id="index-comint_002dterminfo_002dterminal"></a>
<a class="index-entry-id" id="index-system_002duses_002dterminfo"></a>
<a class="index-entry-id" id="index-TERM_002c-environment-variable_002c-in-sub_002dshell"></a>
<p>Comint mode sets the <code class="env">TERM</code> environment variable to a safe default
value, but this value disables some useful features.  For example,
color is disabled in applications that use <code class="env">TERM</code> to determine if
color is supported.  Therefore, Emacs provides an option
<code class="code">comint-terminfo-terminal</code> to let you choose a terminal with more
advanced features, as defined in your system&#8217;s terminfo database.
Emacs will use this option as the value for <code class="env">TERM</code> so long as
<code class="code">system-uses-terminfo</code> is non-<code class="code">nil</code>.
</p>
<p>Both <code class="code">comint-terminfo-terminal</code> and <code class="code">system-uses-terminfo</code>
can be declared as connection-local variables to adjust these options
to match what a remote system expects (see <a class="pxref" href="Customization.xhtml#Connection-Variables">Per-Connection Local Variables</a>).
</p>
</div>
<div class="section-level-extent" id="Terminal-emulator">
<h3 class="section subsection-level-set-section" id="Emacs-Terminal-Emulator">39.8 Emacs Terminal Emulator</h3>
<a class="index-entry-id" id="index-term"></a>

<p>To run a subshell in a text terminal emulator, use <kbd class="kbd">M-x term</kbd>.
This creates (or reuses) a buffer named <samp class="file">*terminal*</samp>, and runs a
subshell with input coming from your keyboard, and output going to
that buffer.
</p>
<a class="index-entry-id" id="index-line-mode-_0028terminal-emulator_0029"></a>
<a class="index-entry-id" id="index-char-mode-_0028terminal-emulator_0029"></a>
<p>The terminal emulator uses Term mode, which has two input modes.  In
<em class="dfn">line mode</em>, Term basically acts like Shell mode (see <a class="pxref" href="#Shell-Mode">Shell Mode</a>).  In <em class="dfn">char mode</em>, each character is sent directly to the
subshell, as terminal input; the sole exception is the terminal escape
character, which by default is <kbd class="kbd">C-c</kbd> (see <a class="pxref" href="#Term-Mode">Term Mode</a>).  Any
echoing of your input is the responsibility of the subshell; any
terminal output from the subshell goes into the buffer, advancing
point.
</p>
<p>Some programs (such as Emacs itself) need to control the appearance
of the terminal screen in detail.  They do this by emitting special
control codes.  Term mode recognizes and handles ANSI-standard
VT100-style escape sequences, which are accepted by most modern
terminals, including <code class="command">xterm</code>.  (Hence, you can actually run
Emacs inside an Emacs Term window.)
</p>
<p>The <code class="code">term</code> face specifies the default appearance of text
in the terminal emulator (the default is the same appearance as the
<code class="code">default</code> face).  When terminal control codes are used to change
the appearance of text, these are represented in the terminal emulator
by the faces <code class="code">term-color-black</code>, <code class="code">term-color-red</code>,
<code class="code">term-color-green</code>, <code class="code">term-color-yellow</code>
<code class="code">term-color-blue</code>, <code class="code">term-color-magenta</code>,
<code class="code">term-color-cyan</code>, <code class="code">term-color-white</code>,
<code class="code">term-color-underline</code>, and <code class="code">term-color-bold</code>.
See <a class="xref" href="Display.xhtml#Faces">Text Faces</a>.
</p>
<p>You can also use Term mode to communicate with a device connected to
a serial port.  See <a class="xref" href="#Serial-Terminal">Serial Terminal</a>.
</p>
<p>The file name used to load the subshell is determined the same way
as for Shell mode.  To make multiple terminal emulators, rename the
buffer <samp class="file">*terminal*</samp> to something different using <kbd class="kbd">M-x
rename-uniquely</kbd>, just as with Shell mode.
</p>
<p>Unlike Shell mode, Term mode does not track the current directory by
examining your input.  But some shells can tell Term what the current
directory is.  This is done automatically by <code class="code">bash</code> version 1.15
and later.
</p>
</div>
<div class="section-level-extent" id="Term-Mode">
<h3 class="section subsection-level-set-section" id="Term-Mode-1">39.9 Term Mode</h3>
<a class="index-entry-id" id="index-Term-mode"></a>
<a class="index-entry-id" id="index-mode_002c-Term"></a>

<p>To switch between line and char mode in Term mode, use these
commands:
</p>
<dl class="table">
<dt><a class="index-entry-id" id="index-term_002dline_002dmode"></a>
<a id="index-C_002dc-C_002dj-_0028Term-mode_0029"></a><kbd class="kbd">C-c C-j</kbd></dt>
<dd><p>Switch to line mode (<code class="code">term-line-mode</code>).  Do nothing if already in
line mode.
</p>
</dd>
<dt><a class="index-entry-id" id="index-term_002dchar_002dmode"></a>
<a id="index-C_002dc-C_002dk-_0028Term-mode_0029"></a><kbd class="kbd">C-c C-k</kbd></dt>
<dd><p>Switch to char mode (<code class="code">term-char-mode</code>).  Do nothing if already in
char mode.
</p></dd>
</dl>

<p>The following commands are only available in char mode:
</p>
<dl class="table">
<dt><kbd class="kbd">C-c C-c</kbd></dt>
<dd><p>Send a literal <kbd class="kbd">C-c</kbd> to the sub-shell
(<code class="code">term-interrupt-subjob</code>).
</p>
</dd>
<dt><kbd class="kbd">C-c <var class="var">char</var></kbd></dt>
<dd><p>This is equivalent to <kbd class="kbd">C-x <var class="var">char</var></kbd> in normal Emacs.  For
example, <kbd class="kbd">C-c o</kbd> invokes the global binding of <kbd class="kbd">C-x o</kbd>, which
is normally &#8216;<samp class="samp">other-window</samp>&#8217;.
</p></dd>
</dl>

<a class="index-entry-id" id="index-paging-in-Term-mode"></a>
<p>Term mode has a page-at-a-time feature.  When enabled, it makes
output pause at the end of each screenful:
</p>
<dl class="table">
<dt><a class="index-entry-id" id="index-term_002dpager_002dtoggle"></a>
<a id="index-C_002dc-C_002dq-_0028Term-mode_0029"></a><kbd class="kbd">C-c C-q</kbd></dt>
<dd><p>Toggle the page-at-a-time feature (<code class="code">term-pager-toggle</code>).  This
command works in both line and char modes.  When the feature is
enabled, the mode-line displays the word &#8216;<samp class="samp">page</samp>&#8217;, and each time
Term receives more than a screenful of output, it pauses and displays
&#8216;<samp class="samp">**MORE**</samp>&#8217; in the mode-line.  Type <kbd class="key">SPC</kbd> to display the next
screenful of output, or <kbd class="kbd">?</kbd> to see your other options.  The
interface is similar to the <code class="code">more</code> program.
</p></dd>
</dl>

</div>
<div class="section-level-extent" id="Remote-Host">
<h3 class="section subsection-level-set-section" id="Remote-Host-Shell">39.10 Remote Host Shell</h3>
<a class="index-entry-id" id="index-remote-host"></a>
<a class="index-entry-id" id="index-connecting-to-remote-host"></a>
<a class="index-entry-id" id="index-Telnet"></a>
<a class="index-entry-id" id="index-SSH"></a>

<p>You can login to a remote computer, using whatever commands you
would from a regular terminal (e.g., the <code class="command">ssh</code> command), from
a Term window.
</p>
<p>A program that asks you for a password will normally suppress
echoing of the password, so the password will not show up in the
buffer.  This will happen just as if you were using a real terminal,
if the buffer is in char mode.  If it is in line mode, the password is
temporarily visible, but will be erased when you hit return.  (This
happens automatically; there is no special password processing.)
</p>
<p>When you log in to a different machine, you need to specify the type
of terminal you&#8217;re using, by setting the <code class="env">TERM</code> environment
variable in the environment for the remote login command.  (If you use
bash, you do that by writing the variable assignment before the remote
login command, without a separating comma.)  Terminal types
&#8216;<samp class="samp">ansi</samp>&#8217; or &#8216;<samp class="samp">vt100</samp>&#8217; will work on most systems.
</p>
</div>
<div class="section-level-extent" id="Serial-Terminal">
<h3 class="section subsection-level-set-section" id="Serial-Terminal-1">39.11 Serial Terminal</h3>
<a class="index-entry-id" id="index-terminal_002c-serial"></a>
<a class="index-entry-id" id="index-serial_002dterm"></a>

<p>If you have a device connected to a serial port of your computer,
you can communicate with it by typing <kbd class="kbd">M-x serial-term</kbd>.  This
command asks for a serial port name and speed, and switches to a new
Term mode buffer.  Emacs communicates with the serial device through
this buffer just like it does with a terminal in ordinary Term mode.
</p>
<p>The speed of the serial port is measured in bits per second.  The
most common speed is 9600 bits per second.  You can change the speed
interactively by clicking on the mode line.
</p>
<p>A serial port can be configured even more by clicking on &#8216;<samp class="samp">8N1</samp>&#8217; in
the mode line.  By default, a serial port is configured as &#8216;<samp class="samp">8N1</samp>&#8217;,
which means that each byte consists of 8 data bits, No parity check
bit, and 1 stopbit.
</p>
<p>If the speed or the configuration is wrong, you cannot communicate
with your device and will probably only see garbage output in the
window.
</p>
</div>
</div>
<div class="footnotes-segment">
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT21" href="#DOCF21">(21)</a></h5>
<p>You should not suspend the shell process.
Suspending a subjob of the shell is a completely different matter&#8212;that
is normal practice, but you must use the shell to continue the subjob;
this command won&#8217;t do it.</p>
</div>



</body>
</html>
