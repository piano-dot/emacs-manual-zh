<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- 这是 GNU Emacs 手册,
为 Emacs  29.2 更新

英文原版版权提示 - Original English version copyright note

Copyright © 1985-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "The GNU Manifesto," "Distribution" and
"GNU GENERAL PUBLIC LICENSE," with the Front-Cover Texts being "A GNU
Manual," and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."

中文翻译版版权提示 - Chinese translation revision copyright notice

版权所有 © 1985-2024 林羿轩(Ralph Lin).

您有在 Free Software Foundation发布的GNU Free Documentation License 第1.3版或之后版本的约束下对其进行再发布及修的权利。 恒定章节为 "The GNU Manifesto," "分发" "(中文版)GNU GENERAL PUBLIC LICENSE" 和
"GNU GENERAL PUBLIC LICENSE" , 前封面文字为 "A GNU
Manual,"后封面文字如下(a).  本书的FDL许可证可以在 "GNU Free Documentation
License."找到.

(a) FSF的后封面文字为: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."
 -->
<title>13 Killing and Moving Text (GNU Emacs Manual)</title>

<meta name="description" content="13 Killing and Moving Text (GNU Emacs Manual)"/>
<meta name="keywords" content="13 Killing and Moving Text (GNU Emacs Manual)"/>
<meta name="resource-type" content="document"/>
<meta name="distribution" content="global"/>
<meta name="Generator" content="texi2any"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>

<link href="emacs.xhtml" rel="start" title="Emacs 编辑器"/>
<link href="Key-Index.xhtml" rel="index" title="Key (Character) Index"/>
<link href="emacs.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="emacs.xhtml" rel="up" title="Emacs 编辑器"/>
<link href="Registers.xhtml#Registers" rel="next" title="14 Registers"/>
<link href="Mark.xhtml#Mark" rel="prev" title="12 The Mark and the Region"/>
<style type="text/css">
<!--
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
kbd.key {font-style: normal}
-->
</style>


</head>

<body lang="zh_CN">
<div class="chapter-level-extent" id="Killing">

<h2 class="chapter" id="Killing-and-Moving-Text">13 Killing and Moving Text</h2>

<p>In Emacs, <em class="dfn">killing</em> means erasing text and copying it into the
<em class="dfn">kill ring</em>.  <em class="dfn">Yanking</em> means bringing text from the kill ring
back into the buffer.  (Some applications use the terms &#8220;cutting&#8221;
and &#8220;pasting&#8221; for similar operations.)  The kill ring is so-named
because it can be visualized as a set of blocks of text arranged in a
ring, which you can access in cyclic order.  See <a class="xref" href="#Kill-Ring">The Kill Ring</a>.
</p>
<p>Killing and yanking are the most common way to move or copy text
within Emacs.  It is very versatile, because there are commands for
killing many different types of syntactic units.
</p>

<div class="section-level-extent" id="Deletion-and-Killing">
<h3 class="section" id="Deletion-and-Killing-1">13.1 Deletion and Killing</h3>

<a class="index-entry-id" id="index-killing-text"></a>
<a class="index-entry-id" id="index-cutting-text"></a>
<a class="index-entry-id" id="index-deletion"></a>
<p>Most commands which erase text from the buffer save it in the kill
ring (see <a class="pxref" href="#Kill-Ring">The Kill Ring</a>).  These are known as <em class="dfn">kill</em> commands, and
their names normally contain the word &#8216;<samp class="samp">kill</samp>&#8217; (e.g.,
<code class="code">kill-line</code>).  The kill ring stores several recent kills, not
just the last one, so killing is a very safe operation: you don&#8217;t have
to worry much about losing text that you previously killed.  The kill
ring is shared by all buffers, so text that is killed in one buffer
can be yanked into another buffer.
</p>
<p>When you use <kbd class="kbd">C-/</kbd> (<code class="code">undo</code>) to undo a kill command
(see <a class="pxref" href="Fixit.xhtml#Undo">Undo</a>), that brings the killed text back into the buffer, but
does not remove it from the kill ring.
</p>
<p>On graphical displays, killing text also copies it to the system
clipboard.  See <a class="xref" href="#Cut-and-Paste">&#8220;Cut and Paste&#8221; Operations on Graphical Displays</a>.
</p>
<p>Commands that erase text but do not save it in the kill ring are
known as <em class="dfn">delete</em> commands; their names usually contain the word
&#8216;<samp class="samp">delete</samp>&#8217;.  These include <kbd class="kbd">C-d</kbd> (<code class="code">delete-char</code>) and
<kbd class="key">DEL</kbd> (<code class="code">delete-backward-char</code>), which delete only one
character at a time, and those commands that delete only spaces or
newlines.  Commands that can erase significant amounts of nontrivial
data generally do a kill operation instead.
</p>
<p>You can also use the mouse to kill and yank.  See <a class="xref" href="#Cut-and-Paste">&#8220;Cut and Paste&#8221; Operations on Graphical Displays</a>.
</p>

<div class="subsection-level-extent" id="Deletion">
<h4 class="subsection" id="Deletion-1">13.1.1 Deletion</h4>
<a class="index-entry-id" id="index-delete_002dbackward_002dchar"></a>
<a class="index-entry-id" id="index-delete_002dchar"></a>

<p>Deletion means erasing text and not saving it in the kill ring.  For
the most part, the Emacs commands that delete text are those that
erase just one character or only whitespace.
</p>
<dl class="table">
<dt><kbd class="kbd"><kbd class="key">DEL</kbd></kbd></dt>
<dt><kbd class="kbd"><kbd class="key">BACKSPACE</kbd></kbd></dt>
<dd><p>Delete the previous character, or the text in the region if it is
active (<code class="code">delete-backward-char</code>).
</p>
</dd>
<dt><kbd class="kbd"><kbd class="key">Delete</kbd></kbd></dt>
<dd><p>Delete the next character, or the text in the region if it is active
(<code class="code">delete-forward-char</code>).
</p>
</dd>
<dt><kbd class="kbd">C-d</kbd></dt>
<dd><p>Delete the next character (<code class="code">delete-char</code>).
</p>
</dd>
<dt><kbd class="kbd">M-\</kbd></dt>
<dd><p>Delete spaces and tabs around point (<code class="code">delete-horizontal-space</code>).
</p></dd>
<dt><kbd class="kbd">M-<kbd class="key">SPC</kbd></kbd></dt>
<dd><p>Delete spaces and tabs around point, leaving one space
(<code class="code">just-one-space</code>).
</p></dd>
<dt><kbd class="kbd">C-x C-o</kbd></dt>
<dd><p>Delete blank lines around the current line (<code class="code">delete-blank-lines</code>).
</p></dd>
<dt><kbd class="kbd">M-^</kbd></dt>
<dd><p>Join two lines by deleting the intervening newline, along with any
indentation following it (<code class="code">delete-indentation</code>).
</p></dd>
</dl>

<p>We have already described the basic deletion commands <kbd class="key">DEL</kbd>
(<code class="code">delete-backward-char</code>), <kbd class="key">delete</kbd>
(<code class="code">delete-forward-char</code>), and <kbd class="kbd">C-d</kbd> (<code class="code">delete-char</code>).
See <a class="xref" href="Basic.xhtml#Erasing">Erasing Text</a>.  With a numeric argument, they delete the specified
number of characters.  If the numeric argument is omitted or one,
<kbd class="key">DEL</kbd> and <kbd class="key">delete</kbd> delete all the text in the region if it is
active (see <a class="pxref" href="Mark.xhtml#Using-Region">Operating on the Region</a>).
</p>
<a class="index-entry-id" id="index-M_002d_005c"></a>
<a class="index-entry-id" id="index-delete_002dhorizontal_002dspace"></a>
<p>The other delete commands are those that delete only whitespace
characters: spaces, tabs and newlines.  <kbd class="kbd">M-\</kbd>
(<code class="code">delete-horizontal-space</code>) deletes all the spaces and tab
characters before and after point.  With a prefix argument, this only
deletes spaces and tab characters before point.
</p>
<a class="index-entry-id" id="index-just_002done_002dspace"></a>
<p><code class="code">just-one-space</code> does likewise but leaves a single space before
point, regardless of the number of spaces that existed previously
(even if there were none before).  With a numeric argument <var class="var">n</var>, it
leaves <var class="var">n</var> spaces before point if <var class="var">n</var> is positive; if <var class="var">n</var>
is negative, it deletes newlines in addition to spaces and tabs,
leaving &#8722;<var class="var">n</var> spaces before point.
</p>
<a class="index-entry-id" id="index-M_002dSPC"></a>
<a class="index-entry-id" id="index-cycle_002dspacing"></a>
<a class="index-entry-id" id="index-cycle_002dspacing_002dactions"></a>
<p>The command <code class="code">cycle-spacing</code> (<kbd class="kbd">M-<kbd class="key">SPC</kbd></kbd>) acts like a more
flexible version of <code class="code">just-one-space</code>.  It performs different
space cleanup actions defined by <code class="code">cycle-spacing-actions</code>, in a
cyclic manner, if you call it repeatedly in succession.
</p>
<p><kbd class="kbd">C-x C-o</kbd> (<code class="code">delete-blank-lines</code>) deletes all blank lines
after the current line.  If the current line is blank, it deletes all
blank lines preceding the current line as well (leaving one blank line,
the current line).  On a solitary blank line, it deletes that line.
</p>
<p><kbd class="kbd">M-^</kbd> (<code class="code">delete-indentation</code>) joins the current line and the
previous line, by deleting a newline and all surrounding spaces, usually
leaving a single space.  See <a class="xref" href="Indentation.xhtml#Indentation">M-^</a>.
</p>
<a class="index-entry-id" id="index-delete_002dduplicate_002dlines"></a>
<p>The command <code class="code">delete-duplicate-lines</code> searches the region for
identical lines, and removes all but one copy of each.  Normally it
keeps the first instance of each repeated line, but with a <kbd class="kbd">C-u</kbd>
prefix argument it keeps the last.  With a <kbd class="kbd">C-u C-u</kbd> prefix
argument, it only searches for adjacent identical lines.  This is a
more efficient mode of operation, useful when the lines have already
been sorted.  With a <kbd class="kbd">C-u C-u C-u</kbd> prefix argument, it retains
repeated blank lines.
</p>
</div>
<div class="subsection-level-extent" id="Killing-by-Lines">
<h4 class="subsection" id="Killing-by-Lines-1">13.1.2 Killing by Lines</h4>

<dl class="table">
<dt><kbd class="kbd">C-k</kbd></dt>
<dd><p>Kill rest of line or one or more lines (<code class="code">kill-line</code>).
</p></dd>
<dt><kbd class="kbd">C-S-backspace</kbd></dt>
<dd><p>Kill an entire line at once (<code class="code">kill-whole-line</code>)
</p></dd>
</dl>

<a class="index-entry-id" id="index-C_002dk"></a>
<a class="index-entry-id" id="index-kill_002dline"></a>
<p>The simplest kill command is <kbd class="kbd">C-k</kbd> (<code class="code">kill-line</code>).  If used
at the end of a line, it kills the line-ending newline character,
merging the next line into the current one (thus, a blank line is
entirely removed).  Otherwise, <kbd class="kbd">C-k</kbd> kills all the text from point
up to the end of the line; if point was originally at the beginning of
the line, this leaves the line blank.
</p>
<p>Spaces and tabs at the end of the line are ignored when deciding
which case applies.  As long as point is after the last non-whitespace
character in the line, you can be sure that <kbd class="kbd">C-k</kbd> will kill the
newline.  To kill an entire non-blank line, go to the beginning and
type <kbd class="kbd">C-k</kbd> twice.
</p>
<p>In this context, &#8220;line&#8221; means a logical text line, not a screen
line (see <a class="pxref" href="Basic.xhtml#Continuation-Lines">Continuation Lines</a>).
</p>
<p>When <kbd class="kbd">C-k</kbd> is given a positive argument <var class="var">n</var>, it kills
<var class="var">n</var> lines and the newlines that follow them (text on the current
line before point is not killed).  With a negative argument
&#8722;<var class="var">n</var>, it kills <var class="var">n</var> lines preceding the current line,
together with the text on the current line before point.  <kbd class="kbd">C-k</kbd>
with an argument of zero kills the text before point on the current
line.
</p>
<a class="index-entry-id" id="index-kill_002dwhole_002dline-1"></a>
<p>If the variable <code class="code">kill-whole-line</code> is non-<code class="code">nil</code>, <kbd class="kbd">C-k</kbd> at
the very beginning of a line kills the entire line including the
following newline.  This variable is normally <code class="code">nil</code>.
</p>
<a class="index-entry-id" id="index-C_002dS_002dbackspace"></a>
<a class="index-entry-id" id="index-kill_002dwhole_002dline"></a>
<p><kbd class="kbd">C-S-backspace</kbd> (<code class="code">kill-whole-line</code>) kills a whole line
including its newline, regardless of the position of point within the
line.  Note that many text terminals will prevent you from typing the
key sequence <kbd class="kbd">C-S-backspace</kbd>.
</p>
</div>
<div class="subsection-level-extent" id="Other-Kill-Commands">
<h4 class="subsection" id="Other-Kill-Commands-1">13.1.3 Other Kill Commands</h4>

<dl class="table">
<dt><kbd class="kbd">C-w</kbd></dt>
<dd><p>Kill the region (<code class="code">kill-region</code>).
</p></dd>
<dt><kbd class="kbd">M-w</kbd></dt>
<dd><p>Copy the region into the kill ring (<code class="code">kill-ring-save</code>).
</p></dd>
<dt><kbd class="kbd">M-d</kbd></dt>
<dd><p>Kill the next word (<code class="code">kill-word</code>).  See <a class="xref" href="Text.xhtml#Words">Words</a>.
</p></dd>
<dt><kbd class="kbd">M-<kbd class="key">DEL</kbd></kbd></dt>
<dd><p>Kill one word backwards (<code class="code">backward-kill-word</code>).
</p></dd>
<dt><kbd class="kbd">C-x <kbd class="key">DEL</kbd></kbd></dt>
<dd><p>Kill back to beginning of sentence (<code class="code">backward-kill-sentence</code>).
See <a class="xref" href="Text.xhtml#Sentences">Sentences</a>.
</p></dd>
<dt><kbd class="kbd">M-k</kbd></dt>
<dd><p>Kill to the end of the sentence (<code class="code">kill-sentence</code>).
</p></dd>
<dt><kbd class="kbd">C-M-k</kbd></dt>
<dd><p>Kill the following balanced expression (<code class="code">kill-sexp</code>).  See <a class="xref" href="Programs.xhtml#Expressions">Expressions with Balanced Parentheses</a>.
</p></dd>
<dt><kbd class="kbd">M-z <var class="var">char</var></kbd></dt>
<dd><p>Kill through the next occurrence of <var class="var">char</var> (<code class="code">zap-to-char</code>).
</p></dd>
<dt><kbd class="kbd">M-x zap-up-to-char <var class="var">char</var></kbd></dt>
<dd><p>Kill up to, but not including, the next occurrence of <var class="var">char</var>.
</p></dd>
</dl>

<a class="index-entry-id" id="index-C_002dw"></a>
<a class="index-entry-id" id="index-kill_002dregion"></a>
<a class="index-entry-id" id="index-M_002dw"></a>
<a class="index-entry-id" id="index-kill_002dring_002dsave"></a>
<p>One of the commonly-used kill commands is <kbd class="kbd">C-w</kbd>
(<code class="code">kill-region</code>), which kills the text in the region
(see <a class="pxref" href="Mark.xhtml#Mark">The Mark and the Region</a>).  Similarly, <kbd class="kbd">M-w</kbd> (<code class="code">kill-ring-save</code>) copies
the text in the region into the kill ring without removing it from the
buffer.  If the mark is inactive when you type <kbd class="kbd">C-w</kbd> or <kbd class="kbd">M-w</kbd>,
the command acts on the text between point and where you last set the
mark (see <a class="pxref" href="Mark.xhtml#Using-Region">Operating on the Region</a>).
</p>
<p>Emacs also provides commands to kill specific syntactic units:
words, with <kbd class="kbd">M-<kbd class="key">DEL</kbd></kbd> and <kbd class="kbd">M-d</kbd> (see <a class="pxref" href="Text.xhtml#Words">Words</a>); balanced
expressions, with <kbd class="kbd">C-M-k</kbd> (see <a class="pxref" href="Programs.xhtml#Expressions">Expressions with Balanced Parentheses</a>); and sentences,
with <kbd class="kbd">C-x <kbd class="key">DEL</kbd></kbd> and <kbd class="kbd">M-k</kbd> (see <a class="pxref" href="Text.xhtml#Sentences">Sentences</a>).
</p>
<a class="index-entry-id" id="index-M_002dz"></a>
<a class="index-entry-id" id="index-zap_002dto_002dchar"></a>
<p>The command <kbd class="kbd">M-z</kbd> (<code class="code">zap-to-char</code>) combines killing with
searching: it reads a character and kills from point up to (and
including) the next occurrence of that character in the buffer.  A
numeric argument acts as a repeat count; a negative argument means to
search backward and kill text before point.  A history of previously
used characters is maintained and can be accessed via the
<kbd class="kbd">M-p</kbd>/<kbd class="kbd">M-n</kbd> keystrokes.  This is mainly useful if the
character to be used has to be entered via a complicated input method.
<a class="index-entry-id" id="index-zap_002dup_002dto_002dchar"></a>
A similar command <code class="code">zap-up-to-char</code> kills from point up to, but
not including the next occurrence of a character, with numeric
argument acting as a repeat count.
</p>
</div>
<div class="subsection-level-extent" id="Kill-Options">
<h4 class="subsection" id="Options-for-Killing">13.1.4 Options for Killing</h4>

<a class="index-entry-id" id="index-kill_002dread_002donly_002dok"></a>
<a class="index-entry-id" id="index-read_002donly-text_002c-killing"></a>
<p>Some specialized buffers contain <em class="dfn">read-only text</em>, which cannot
be modified and therefore cannot be killed.  The kill commands work
specially in a read-only buffer: they move over text and copy it to
the kill ring, without actually deleting it from the buffer.
Normally, they also beep and display an error message when this
happens.  But if you set the variable <code class="code">kill-read-only-ok</code> to a
non-<code class="code">nil</code> value, they just print a message in the echo area to
explain why the text has not been erased.
</p>
<a class="index-entry-id" id="index-kill_002dtransform_002dfunction"></a>
<p>Before saving the kill to the kill ring, you can transform the
string using <code class="code">kill-transform-function</code>.  It&#8217;s called with the
string to be killed, and it should return the string you want to be
saved.  It can also return <code class="code">nil</code>, in which case the string won&#8217;t
be saved to the kill ring.  For instance, if you never want to save
a pure white space string to the kill ring, you can say:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(setq kill-transform-function
      (lambda (string)
        (and (not (string-blank-p string))
             string)))
</pre></div>

<a class="index-entry-id" id="index-kill_002ddo_002dnot_002dsave_002dduplicates"></a>
<p>If you change the variable <code class="code">kill-do-not-save-duplicates</code> to a
non-<code class="code">nil</code> value, identical subsequent kills yield a single
kill-ring entry, without duplication.
</p>
</div>
</div>
<div class="section-level-extent" id="Yanking">
<h3 class="section" id="Yanking-1">13.2 Yanking</h3>
<a class="index-entry-id" id="index-moving-text"></a>
<a class="index-entry-id" id="index-copying-text"></a>
<a class="index-entry-id" id="index-kill-ring"></a>
<a class="index-entry-id" id="index-yanking"></a>
<a class="index-entry-id" id="index-pasting"></a>

<p><em class="dfn">Yanking</em> means reinserting text previously killed.  The usual
way to move or copy text is to kill it and then yank it elsewhere.
</p>
<dl class="table">
<dt><kbd class="kbd">C-y</kbd></dt>
<dd><p>Yank the last kill into the buffer, at point (<code class="code">yank</code>).
</p></dd>
<dt><kbd class="kbd">M-y</kbd></dt>
<dd><p>Either replace the text just yanked with an earlier batch of killed
text (<code class="code">yank-pop</code>), or allow to select from the list of
previously-killed batches of text.  See <a class="xref" href="#Earlier-Kills">Yanking Earlier Kills</a>.
</p></dd>
<dt><kbd class="kbd">C-M-w</kbd></dt>
<dd><p>Cause the following command, if it is a kill command, to append to the
previous kill (<code class="code">append-next-kill</code>).  See <a class="xref" href="#Appending-Kills">Appending Kills</a>.
</p></dd>
</dl>

<a class="index-entry-id" id="index-C_002dy"></a>
<a class="index-entry-id" id="index-yank"></a>
<p>The basic yanking command is <kbd class="kbd">C-y</kbd> (<code class="code">yank</code>).  It inserts
the most recent kill, leaving the cursor at the end of the inserted
text.  It also sets the mark at the beginning of the inserted text,
without activating the mark; this lets you jump easily to that
position, if you wish, with <kbd class="kbd">C-u C-<kbd class="key">SPC</kbd></kbd> (see <a class="pxref" href="Mark.xhtml#Mark-Ring">The Mark Ring</a>).
</p>
<p>With a plain prefix argument (<kbd class="kbd">C-u C-y</kbd>), the command instead
leaves the cursor in front of the inserted text, and sets the mark at
the end.  Using any other prefix argument specifies an earlier kill;
e.g., <kbd class="kbd">C-u 4 C-y</kbd> reinserts the fourth most recent kill.
See <a class="xref" href="#Earlier-Kills">Yanking Earlier Kills</a>.
</p>
<p>On graphical displays and on capable text-mode displays, <kbd class="kbd">C-y</kbd>
first checks if another application has placed any text in the system
clipboard more recently than the last Emacs kill.  If so, it inserts
the clipboard&#8217;s text instead.  Thus, Emacs effectively treats &#8220;cut&#8221;
or &#8220;copy&#8221; clipboard operations performed in other applications like
Emacs kills, except that they are not recorded in the kill ring.
See <a class="xref" href="#Cut-and-Paste">&#8220;Cut and Paste&#8221; Operations on Graphical Displays</a>, for details.
</p>

<div class="subsection-level-extent" id="Kill-Ring">
<h4 class="subsection" id="The-Kill-Ring">13.2.1 The Kill Ring</h4>

<p>The <em class="dfn">kill ring</em> is a list of blocks of text that were previously
killed.  There is only one kill ring, shared by all buffers, so you
can kill text in one buffer and yank it in another buffer.  This is
the usual way to move text from one buffer to another.  (There are
several other methods: for instance, you could store the text in a
register; see <a class="ref" href="Registers.xhtml#Registers">Registers</a>.  See <a class="xref" href="#Accumulating-Text">Accumulating Text</a>, for some
other ways to move text around.)
</p>
<a class="index-entry-id" id="index-kill_002dring_002dmax"></a>
<p>The maximum number of entries in the kill ring is controlled by the
variable <code class="code">kill-ring-max</code>.  The default is 120.  If you make a new
kill when this limit has been reached, Emacs makes room by deleting
the oldest entry in the kill ring.
</p>
<a class="index-entry-id" id="index-kill_002dring"></a>
<p>The actual contents of the kill ring are stored in a variable named
<code class="code">kill-ring</code>; you can view the entire contents of the kill ring
with <kbd class="kbd">C-h v kill-ring</kbd>.
</p>
</div>
<div class="subsection-level-extent" id="Earlier-Kills">
<h4 class="subsection" id="Yanking-Earlier-Kills">13.2.2 Yanking Earlier Kills</h4>
<a class="index-entry-id" id="index-yanking-previous-kills"></a>

<p>As explained in <a class="ref" href="#Yanking">Yanking</a>, you can use a numeric argument to
<kbd class="kbd">C-y</kbd> to yank text that is no longer the most recent kill.  This
is useful if you remember which kill ring entry you want.  If you
don&#8217;t, you can use the <kbd class="kbd">M-y</kbd> (<code class="code">yank-pop</code>) command to cycle
through the possibilities or to select one of the earlier kills.
</p>
<a class="index-entry-id" id="index-M_002dy"></a>
<a class="index-entry-id" id="index-yank_002dpop"></a>
<p>If the previous command was a yank command, <kbd class="kbd">M-y</kbd> takes the text
that was yanked and replaces it with the text from an earlier kill.
So, to recover the text of the next-to-the-last kill, first use
<kbd class="kbd">C-y</kbd> to yank the last kill, and then use <kbd class="kbd">M-y</kbd> to replace it
with the previous kill.  This works only after a <kbd class="kbd">C-y</kbd>
or another <kbd class="kbd">M-y</kbd>.  (If <kbd class="kbd">M-y</kbd> is invoked after some other
command, it works differently, see below.)
</p>
<p>You can understand this operation mode of <kbd class="kbd">M-y</kbd> in terms of a
last-yank pointer which points at an entry in the kill ring.  Each
time you kill, the last-yank pointer moves to the newly made entry at
the front of the ring.  <kbd class="kbd">C-y</kbd> yanks the entry which the last-yank
pointer points to.  <kbd class="kbd">M-y</kbd> after a <kbd class="kbd">C-y</kbd> or another <kbd class="kbd">M-y</kbd>
moves the last-yank pointer to the previous entry, and the text in the
buffer changes to match.  Enough <kbd class="kbd">M-y</kbd> commands one after another
can move the pointer to any entry in the ring, so you can get any
entry into the buffer.  Eventually the pointer reaches the end of the
ring; the next <kbd class="kbd">M-y</kbd> loops back around to the first entry again.
</p>
<p><kbd class="kbd">M-y</kbd> moves the last-yank pointer around the ring, but it does
not change the order of the entries in the ring, which always runs from
the most recent kill at the front to the oldest one still remembered.
</p>
<p>When used after <kbd class="kbd">C-y</kbd> or <kbd class="kbd">M-y</kbd>, <kbd class="kbd">M-y</kbd> can take a numeric
argument, which tells it how many entries to advance the last-yank
pointer by.  A negative argument moves the pointer toward the front of
the ring; from the front of the ring, it moves around to the last
entry and continues forward from there.
</p>
<p>Once the text you are looking for is brought into the buffer, you
can stop doing <kbd class="kbd">M-y</kbd> commands and the last yanked text will stay
there.  It&#8217;s just a copy of the kill ring entry, so editing it in the
buffer does not change what&#8217;s in the ring.  As long as no new killing
is done, the last-yank pointer remains at the same place in the kill
ring, so repeating <kbd class="kbd">C-y</kbd> will yank another copy of the same
previous kill.
</p>
<p>When you call <kbd class="kbd">C-y</kbd> with a numeric argument, that also sets the
last-yank pointer to the entry that it yanks.
</p>
<p>You can also invoke <kbd class="kbd">M-y</kbd> after a command that is not a yank
command.  In that case, <kbd class="kbd">M-y</kbd> prompts you in the minibuffer for
one of the previous kills.  You can use the minibuffer history
commands (see <a class="pxref" href="Minibuffer.xhtml#Minibuffer-History">Minibuffer History</a>) to navigate or search through
the entries in the kill ring until you find the one you want to
reinsert.  Or you can use completion commands (see <a class="pxref" href="Minibuffer.xhtml#Completion-Commands">Completion Commands</a>) to complete on an entry from the list of entries in the
kill ring or pop up the <samp class="file">*Completions*</samp> buffer with the candidate
entries from which you can choose.  After selecting the kill-ring
entry, you can optionally edit it in the minibuffer.  Finally, type
<kbd class="kbd">RET</kbd> to exit the minibuffer and insert the text of the selected
kill-ring entry.  Like in case of <kbd class="kbd">M-y</kbd> after another yank
command, the last-yank pointer is left pointing at the text you just
yanked, whether it is one of the previous kills or an entry from the
kill-ring that you edited before inserting it.  (In the latter case,
the edited entry is added to the front of the kill-ring.)  So here,
too, typing <kbd class="kbd">C-y</kbd> will yank another copy of the text just
inserted.
</p>
<p>When invoked with a plain prefix argument (<kbd class="kbd">C-u M-y</kbd>) after a
command that is not a yank command, <kbd class="kbd">M-y</kbd> leaves the cursor in
front of the inserted text, and sets the mark at the end, like
<kbd class="kbd">C-y</kbd> does.
</p>
</div>
<div class="subsection-level-extent" id="Appending-Kills">
<h4 class="subsection" id="Appending-Kills-1">13.2.3 Appending Kills</h4>

<a class="index-entry-id" id="index-appending-kills-in-the-ring"></a>
<p>Normally, each kill command pushes a new entry onto the kill ring.
However, two or more kill commands in a row combine their text into a
single entry, so that a single <kbd class="kbd">C-y</kbd> yanks all the text as a unit,
just as it was before it was killed.
</p>
<p>Thus, if you want to yank text as a unit, you need not kill all of it
with one command; you can keep killing line after line, or word after
word, until you have killed it all, and you can still get it all back at
once.
</p>
<p>Commands that kill forward from point add onto the end of the previous
killed text.  Commands that kill backward from point add text onto the
beginning.  This way, any sequence of mixed forward and backward kill
commands puts all the killed text into one entry without rearrangement.
Numeric arguments do not break the sequence of appending kills.  For
example, suppose the buffer contains this text:
</p>
<div class="example">
<pre class="example-preformatted">This is a line &#8902;of sample text.
</pre></div>

<p>with point shown by &#8902;.  If you type <kbd class="kbd">M-d M-<kbd class="key">DEL</kbd> M-d
M-<kbd class="key">DEL</kbd></kbd>, killing alternately forward and backward, you end up with
&#8216;<samp class="samp">a line of sample</samp>&#8217; as one entry in the kill ring, and
&#8216;<samp class="samp">This&#160;is&#160;&#160;text.</samp>&#8217;<!-- /@w --> in the buffer.  (Note the double space
between &#8216;<samp class="samp">is</samp>&#8217; and &#8216;<samp class="samp">text</samp>&#8217;, which you can clean up with
<kbd class="kbd">M-<kbd class="key">SPC</kbd></kbd> or <kbd class="kbd">M-q</kbd>.)
</p>
<p>Another way to kill the same text is to move back two words with
<kbd class="kbd">M-b M-b</kbd>, then kill all four words forward with <kbd class="kbd">C-u M-d</kbd>.
This produces exactly the same results in the buffer and in the kill
ring.  <kbd class="kbd">M-f M-f C-u M-<kbd class="key">DEL</kbd></kbd> kills the same text, all going
backward; once again, the result is the same.  The text in the kill ring
entry always has the same order that it had in the buffer before you
killed it.
</p>
<a class="index-entry-id" id="index-C_002dM_002dw"></a>
<a class="index-entry-id" id="index-append_002dnext_002dkill"></a>
<p>If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the
kill ring.  But you can force it to combine with the last killed text,
by typing <kbd class="kbd">C-M-w</kbd> (<code class="code">append-next-kill</code>) right beforehand.  The
<kbd class="kbd">C-M-w</kbd> tells its following command, if it is a kill command, to
treat the kill as part of the sequence of previous kills.  As usual,
the kill is appended to the previous killed text if the command kills
forward, and prepended if the command kills backward.  In this way,
you can kill several separated pieces of text and accumulate them to
be yanked back in one place.
</p>
<p>A kill command following <kbd class="kbd">M-w</kbd> (<code class="code">kill-ring-save</code>) does not
append to the text that <kbd class="kbd">M-w</kbd> copied into the kill ring.
</p>
</div>
</div>
<div class="section-level-extent" id="Cut-and-Paste">
<h3 class="section" id="g_t_0060_0060Cut-and-Paste_0027_0027-Operations-on-Graphical-Displays">13.3 &#8220;Cut and Paste&#8221; Operations on Graphical Displays</h3>
<a class="index-entry-id" id="index-cut"></a>
<a class="index-entry-id" id="index-copy"></a>
<a class="index-entry-id" id="index-paste"></a>

<p>In most graphical desktop environments, you can transfer data
(usually text) between different applications using a system facility
called the <em class="dfn">clipboard</em>.  On X, two other similar facilities are
available: the primary selection and the secondary selection.  When
Emacs is run on a graphical display, its kill and yank commands
integrate with these facilities, so that you can easily transfer text
between Emacs and other graphical applications.
</p>
<p>By default, Emacs uses UTF-8 as the coding system for inter-program
text transfers.  If you find that the pasted text is not what you
expected, you can specify another coding system by typing <kbd class="kbd">C-x
<kbd class="key">RET</kbd> x</kbd> or <kbd class="kbd">C-x <kbd class="key">RET</kbd> X</kbd>.  You can also request a
different data type by customizing <code class="code">x-select-request-type</code>.
See <a class="xref" href="International.xhtml#Communication-Coding">Coding Systems for Interprocess Communication</a>.
</p>

<div class="subsection-level-extent" id="Clipboard">
<h4 class="subsection" id="Using-the-Clipboard">13.3.1 Using the Clipboard</h4>
<a class="index-entry-id" id="index-clipboard"></a>

<p>The <em class="dfn">clipboard</em> is the facility that most graphical applications
use for &#8220;cutting and pasting&#8221;.  When the clipboard exists, the kill
and yank commands in Emacs make use of it.
</p>
<p>When you kill some text with a command such as <kbd class="kbd">C-w</kbd>
(<code class="code">kill-region</code>), or copy it to the kill ring with a command such
as <kbd class="kbd">M-w</kbd> (<code class="code">kill-ring-save</code>), that text is also put in the
clipboard.
</p>
<a class="index-entry-id" id="index-save_002dinterprogram_002dpaste_002dbefore_002dkill"></a>
<p>When an Emacs kill command puts text in the clipboard, the existing
clipboard contents are normally lost.  Optionally, Emacs can save the
existing clipboard contents to the kill ring, preventing you from
losing the old clipboard data.  If
<code class="code">save-interprogram-paste-before-kill</code> has been set to a number,
then the data is copied over if it&#8217;s smaller (in characters) than
this number.  If this variable is any other non-<code class="code">nil</code> value, the
data is always copied over&#8212;at the risk of high memory consumption if
that data turns out to be large.
</p>
<p>Yank commands, such as <kbd class="kbd">C-y</kbd> (<code class="code">yank</code>), also use the
clipboard.  If another application &#8220;owns&#8221; the clipboard&#8212;i.e., if
you cut or copied text there more recently than your last kill command
in Emacs&#8212;then Emacs yanks from the clipboard instead of the kill
ring.
</p>
<a class="index-entry-id" id="index-yank_002dpop_002dchange_002dselection"></a>
<p>Normally, rotating the kill ring with <kbd class="kbd">M-y</kbd> (<code class="code">yank-pop</code>)
does not alter the clipboard.  However, if you change
<code class="code">yank-pop-change-selection</code> to <code class="code">t</code>, then <kbd class="kbd">M-y</kbd> saves the
new yank to the clipboard.
</p>
<a class="index-entry-id" id="index-select_002denable_002dclipboard"></a>
<p>To prevent kill and yank commands from accessing the clipboard,
change the variable <code class="code">select-enable-clipboard</code> to <code class="code">nil</code>.
</p>
<a class="index-entry-id" id="index-yank_002dmedia"></a>
<p>Programs can put other things than plain text on the clipboard.  For
instance, a web browser will usually let you choose &#8220;Copy Image&#8221; on
images, and this image will be put on the clipboard.  On capable
platforms, Emacs can yank these objects with the <code class="code">yank-media</code>
command&#8212;but only in modes that have support for it (see <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Yanking-Media.html#Yanking-Media">Yanking
Media</a> in <cite class="cite">The Emacs Lisp Reference Manual</cite>).
</p>
<a class="index-entry-id" id="index-clipboard-manager"></a>
<a class="index-entry-id" id="index-x_002dselect_002denable_002dclipboard_002dmanager"></a>
<p>Many X desktop environments support a feature called the
<em class="dfn">clipboard manager</em>.  If you exit Emacs while it is the current
&#8220;owner&#8221; of the clipboard data, and there is a clipboard manager
running, Emacs transfers the clipboard data to the clipboard manager
so that it is not lost.  In some circumstances, this may cause a delay
when exiting Emacs; if you wish to prevent Emacs from transferring
data to the clipboard manager, change the variable
<code class="code">x-select-enable-clipboard-manager</code> to <code class="code">nil</code>.
</p>
<p>Since strings containing NUL bytes are usually truncated when passed
through the clipboard, Emacs replaces such characters with &#8220;\0&#8221;
before transferring them to the system&#8217;s clipboard.
</p>
<a class="index-entry-id" id="index-select_002denable_002dprimary"></a>
<a class="index-entry-id" id="index-clipboard_002dkill_002dregion"></a>
<a class="index-entry-id" id="index-clipboard_002dkill_002dring_002dsave"></a>
<a class="index-entry-id" id="index-clipboard_002dyank"></a>
<p>Prior to Emacs 24, the kill and yank commands used the primary
selection (see <a class="pxref" href="#Primary-Selection">Cut and Paste with Other Window Applications</a>), not the clipboard.  If you
prefer this behavior, change <code class="code">select-enable-clipboard</code> to
<code class="code">nil</code>, <code class="code">select-enable-primary</code> to <code class="code">t</code>, and
<code class="code">mouse-drag-copy-region</code> to <code class="code">t</code>.  In this case, you can use
the following commands to act explicitly on the clipboard:
<code class="code">clipboard-kill-region</code> kills the region and saves it to the
clipboard; <code class="code">clipboard-kill-ring-save</code> copies the region to the
kill ring and saves it to the clipboard; and <code class="code">clipboard-yank</code>
yanks the contents of the clipboard at point.
</p>
</div>
<div class="subsection-level-extent" id="Primary-Selection">
<h4 class="subsection" id="Cut-and-Paste-with-Other-Window-Applications">13.3.2 Cut and Paste with Other Window Applications</h4>
<a class="index-entry-id" id="index-X-cutting-and-pasting"></a>
<a class="index-entry-id" id="index-X-selection"></a>
<a class="index-entry-id" id="index-primary-selection"></a>
<a class="index-entry-id" id="index-selection_002c-primary"></a>

<p>Under the X Window System, PGTK and Haiku, there exists a
<em class="dfn">primary selection</em> containing the last stretch of text selected
in an X application (usually by dragging the mouse).  Typically, this
text can be inserted into other X applications by <kbd class="kbd">mouse-2</kbd>
clicks.  The primary selection is separate from the clipboard.  Its
contents are more fragile; they are overwritten each time you select
text with the mouse, whereas the clipboard is only overwritten by
explicit cut or copy commands.
</p>
<p>Under X, whenever the region is active (see <a class="pxref" href="Mark.xhtml#Mark">The Mark and the Region</a>), the text in
the region is saved in the primary selection.  This applies regardless
of whether the region was made by dragging or clicking the mouse
(see <a class="pxref" href="Frames.xhtml#Mouse-Commands">Mouse Commands for Editing</a>), or by keyboard commands (e.g., by typing
<kbd class="kbd">C-<kbd class="key">SPC</kbd></kbd> and moving point; see <a class="pxref" href="Mark.xhtml#Setting-Mark">Setting the Mark</a>).
</p>
<a class="index-entry-id" id="index-select_002dactive_002dregions"></a>
<p>If you change the variable <code class="code">select-active-regions</code> to
<code class="code">only</code>, Emacs saves only temporarily active regions to the
primary selection, i.e., those made with the mouse or with shift
selection (see <a class="pxref" href="Mark.xhtml#Shift-Selection">Shift Selection</a>).  If you change
<code class="code">select-active-regions</code> to <code class="code">nil</code>, Emacs avoids saving active
regions to the primary selection entirely.
</p>
<p>To insert the primary selection into an Emacs buffer, click
<kbd class="kbd">mouse-2</kbd> (<code class="code">mouse-yank-primary</code>) where you want to insert it.
See <a class="xref" href="Frames.xhtml#Mouse-Commands">Mouse Commands for Editing</a>.  You can also use the normal Emacs yank command
(<kbd class="kbd">C-y</kbd>) to insert this text if <code class="code">select-enable-primary</code> is set
(see <a class="pxref" href="#Clipboard">Using the Clipboard</a>).
</p>
<a class="index-entry-id" id="index-lost_002dselection_002dmode"></a>
<p>By default, Emacs keeps the region active even after text is
selected in another program; this is contrary to typical X behavior.
To make Emacs deactivate the region after another program places data
in the primary selection, enable the global minor mode
<code class="code">lost-selection-mode</code>.
</p>
<a class="index-entry-id" id="index-MS_002dWindows_002c-and-primary-selection"></a>
<p>MS-Windows provides no primary selection, but Emacs emulates it
within a single Emacs session by storing the selected text internally.
Therefore, all the features and commands related to the primary
selection work on Windows as they do on X, for cutting and pasting
within the same session, but not across Emacs sessions or with other
applications.
</p>
</div>
<div class="subsection-level-extent" id="Secondary-Selection">
<h4 class="subsection" id="Secondary-Selection-1">13.3.3 Secondary Selection</h4>
<a class="index-entry-id" id="index-secondary-selection"></a>

<p>In addition to the primary selection, the X Window System provides a
second similar facility known as the <em class="dfn">secondary selection</em>.
Nowadays, few X applications make use of the secondary selection, but
you can access it using the following Emacs commands:
</p>
<dl class="table">
<dt><a class="index-entry-id" id="index-M_002dDrag_002dmouse_002d1"></a>
<a class="index-entry-id" id="index-secondary_002dselection-face"></a>
<a id="index-mouse_002dset_002dsecondary"></a><kbd class="kbd">M-Drag-mouse-1</kbd></dt>
<dd><p>Set the secondary selection, with one end at the place where you press
down the button, and the other end at the place where you release it
(<code class="code">mouse-set-secondary</code>).  The selected text is highlighted, using
the <code class="code">secondary-selection</code> face, as you drag.  The window scrolls
automatically if you drag the mouse off the top or bottom of the
window, just like <code class="code">mouse-set-region</code> (see <a class="pxref" href="Frames.xhtml#Mouse-Commands">Mouse Commands for Editing</a>).
</p>
<p>This command does not alter the kill ring.
</p>
</dd>
<dt><a class="index-entry-id" id="index-M_002dmouse_002d1"></a>
<a id="index-mouse_002dstart_002dsecondary"></a><kbd class="kbd">M-mouse-1</kbd></dt>
<dd><p>Set one endpoint for the <em class="dfn">secondary selection</em>
(<code class="code">mouse-start-secondary</code>); use <kbd class="kbd">M-mouse-3</kbd> to set the other
end and complete the selection.  This command cancels any existing
secondary selection, when it starts a new one.
</p>
</dd>
<dt><a class="index-entry-id" id="index-M_002dmouse_002d3"></a>
<a id="index-mouse_002dsecondary_002dsave_002dthen_002dkill"></a><kbd class="kbd">M-mouse-3</kbd></dt>
<dd><p>Set the secondary selection (<code class="code">mouse-secondary-save-then-kill</code>),
with one end at the position you click <kbd class="kbd">M-mouse-3</kbd>, and the other
at the position specified previously with <kbd class="kbd">M-mouse-1</kbd>.  This also
puts the selected text in the kill ring.  A second <kbd class="kbd">M-mouse-3</kbd> at
the same place kills the text selected by the secondary selection just
made.
</p>
</dd>
<dt><a class="index-entry-id" id="index-M_002dmouse_002d2"></a>
<a id="index-mouse_002dyank_002dsecondary"></a><kbd class="kbd">M-mouse-2</kbd></dt>
<dd><p>Insert the secondary selection where you click, placing point at the
end of the yanked text (<code class="code">mouse-yank-secondary</code>).
</p></dd>
</dl>

<p>Double or triple clicking of <kbd class="kbd">M-mouse-1</kbd> operates on words and
lines, much like <kbd class="kbd">mouse-1</kbd>.
</p>
<p>If <code class="code">mouse-yank-at-point</code> is non-<code class="code">nil</code>, <kbd class="kbd">M-mouse-2</kbd> yanks
at point.  Then it does not matter precisely where you click, or even
which of the frame&#8217;s windows you click on.  See <a class="xref" href="Frames.xhtml#Mouse-Commands">Mouse Commands for Editing</a>.
This user option also effects interactive search: if it is
non-<code class="code">nil</code>, yanking with the mouse anywhere in the frame will add
the text to the search string.
</p>
</div>
</div>
<div class="section-level-extent" id="Accumulating-Text">
<h3 class="section" id="Accumulating-Text-1">13.4 Accumulating Text</h3>
<a class="index-entry-id" id="index-append_002dto_002dbuffer"></a>
<a class="index-entry-id" id="index-prepend_002dto_002dbuffer"></a>
<a class="index-entry-id" id="index-copy_002dto_002dbuffer"></a>
<a class="index-entry-id" id="index-append_002dto_002dfile"></a>

<a class="index-entry-id" id="index-accumulating-scattered-text"></a>
<p>Usually we copy or move text by killing it and yanking it, but there
are other convenient methods for copying one block of text in many
places, or for copying many scattered blocks of text into one place.
Here we describe the commands to accumulate scattered pieces of text
into a buffer or into a file.
</p>
<dl class="table">
<dt><kbd class="kbd">M-x append-to-buffer</kbd></dt>
<dd><p>Append region to the contents of a specified buffer.
</p></dd>
<dt><kbd class="kbd">M-x prepend-to-buffer</kbd></dt>
<dd><p>Prepend region to the contents of a specified buffer.
</p></dd>
<dt><kbd class="kbd">M-x copy-to-buffer</kbd></dt>
<dd><p>Copy region into a specified buffer, deleting that buffer&#8217;s old contents.
</p></dd>
<dt><kbd class="kbd">M-x insert-buffer</kbd></dt>
<dd><p>Insert the contents of a specified buffer into current buffer at point.
</p></dd>
<dt><kbd class="kbd">M-x append-to-file</kbd></dt>
<dd><p>Append region to the contents of a specified file, at the end.
</p></dd>
</dl>

<p>To accumulate text into a buffer, use <kbd class="kbd">M-x append-to-buffer</kbd>.
This reads a buffer name, then inserts a copy of the region into the
buffer specified.  If you specify a nonexistent buffer,
<code class="code">append-to-buffer</code> creates the buffer.  The text is inserted
wherever point is in that buffer.  If you have been using the buffer for
editing, the copied text goes into the middle of the text of the buffer,
starting from wherever point happens to be at that moment.
</p>
<p>Point in that buffer is left at the end of the copied text, so
successive uses of <code class="code">append-to-buffer</code> accumulate the text in the
specified buffer in the same order as they were copied.  Strictly
speaking, <code class="code">append-to-buffer</code> does not always append to the text
already in the buffer&#8212;it appends only if point in that buffer is at
the end.  However, if <code class="code">append-to-buffer</code> is the only command you
use to alter a buffer, then point is always at the end.
</p>
<p><kbd class="kbd">M-x prepend-to-buffer</kbd> is just like <code class="code">append-to-buffer</code>
except that point in the other buffer is left before the copied text, so
successive uses of this command add text in reverse order.  <kbd class="kbd">M-x
copy-to-buffer</kbd> is similar, except that any existing text in the other
buffer is deleted, so the buffer is left containing just the text newly
copied into it.
</p>
<p>The command <kbd class="kbd">C-x x i</kbd> (<code class="code">insert-buffer</code>) can be used to
retrieve the accumulated text from another buffer.  This prompts for
the name of a buffer, and inserts a copy of all the text in that
buffer into the current buffer at point, leaving point at the
beginning of the inserted text.  It also adds the position of the end
of the inserted text to the mark ring, without activating the mark.
See <a class="xref" href="Buffers.xhtml#Buffers">Using Multiple Buffers</a>, for background information on buffers.
</p>
<p>Instead of accumulating text in a buffer, you can append text
directly into a file with <kbd class="kbd">M-x append-to-file</kbd>.  This prompts for
a filename, and adds the text of the region to the end of the
specified file.  The file is changed immediately on disk.
</p>
<p>You should use <code class="code">append-to-file</code> only with files that are
<em class="emph">not</em> being visited in Emacs.  Using it on a file that you are
editing in Emacs would change the file behind Emacs&#8217;s back, which
can lead to losing some of your editing.
</p>
<p>Another way to move text around is to store it in a register.
See <a class="xref" href="Registers.xhtml#Registers">Registers</a>.
</p>
</div>
<div class="section-level-extent" id="Rectangles">
<h3 class="section" id="Rectangles-1">13.5 Rectangles</h3>
<a class="index-entry-id" id="index-rectangle"></a>
<a class="index-entry-id" id="index-columns-_0028and-rectangles_0029"></a>
<a class="index-entry-id" id="index-killing-rectangular-areas-of-text"></a>

<p><em class="dfn">Rectangle</em> commands operate on rectangular areas of the text:
all the characters between a certain pair of columns, in a certain
range of lines.  Emacs has commands to kill rectangles, yank killed
rectangles, clear them out, fill them with blanks or text, or delete
them.  Rectangle commands are useful with text in multicolumn formats,
and for changing text into or out of such formats.
</p>
<a class="index-entry-id" id="index-mark-rectangle"></a>
<a class="index-entry-id" id="index-region_002drectangle"></a>
<a class="index-entry-id" id="index-rectangular-region"></a>
<p>To specify a rectangle for a command to work on, set the mark at one
corner and point at the opposite corner.  The rectangle thus specified
is called the <em class="dfn">region-rectangle</em>.  If point and the mark are in
the same column, the region-rectangle is empty.  If they are in the
same line, the region-rectangle is one line high.
</p>
<p>The region-rectangle is controlled in much the same way as the
region is controlled.  But remember that a given combination of point
and mark values can be interpreted either as a region or as a
rectangle, depending on the command that uses them.
</p>
<p>A rectangular region can also be marked using the mouse: click and drag
<kbd class="kbd">C-M-mouse-1</kbd> from one corner of the rectangle to the opposite.
</p>
<dl class="table">
<dt><kbd class="kbd">C-x r k</kbd></dt>
<dd><p>Kill the text of the region-rectangle, saving its contents as the
last killed rectangle (<code class="code">kill-rectangle</code>).
</p></dd>
<dt><kbd class="kbd">C-x r M-w</kbd></dt>
<dd><p>Save the text of the region-rectangle as the last killed rectangle
(<code class="code">copy-rectangle-as-kill</code>).
</p></dd>
<dt><kbd class="kbd">C-x r d</kbd></dt>
<dd><p>Delete the text of the region-rectangle (<code class="code">delete-rectangle</code>).
</p></dd>
<dt><kbd class="kbd">C-x r y</kbd></dt>
<dd><p>Yank the last killed rectangle with its upper left corner at point
(<code class="code">yank-rectangle</code>).
</p></dd>
<dt><kbd class="kbd">C-x r o</kbd></dt>
<dd><p>Insert blank space to fill the space of the region-rectangle
(<code class="code">open-rectangle</code>).  This pushes the previous contents of the
region-rectangle to the right.
</p></dd>
<dt><kbd class="kbd">C-x r N</kbd></dt>
<dd><p>Insert line numbers along the left edge of the region-rectangle
(<code class="code">rectangle-number-lines</code>).  This pushes the previous contents of
the region-rectangle to the right.
</p></dd>
<dt><kbd class="kbd">C-x r c</kbd></dt>
<dd><p>Clear the region-rectangle by replacing all of its contents with spaces
(<code class="code">clear-rectangle</code>).
</p></dd>
<dt><kbd class="kbd">M-x delete-whitespace-rectangle</kbd></dt>
<dd><p>Delete whitespace in each of the lines on the specified rectangle,
starting from the left edge column of the rectangle.
</p></dd>
<dt><kbd class="kbd">C-x r t <var class="var">string</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Replace rectangle contents with <var class="var">string</var> on each line
(<code class="code">string-rectangle</code>).
</p></dd>
<dt><kbd class="kbd">M-x string-insert-rectangle <kbd class="key">RET</kbd> <var class="var">string</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Insert <var class="var">string</var> on each line of the rectangle.
</p></dd>
<dt><kbd class="kbd">C-x <kbd class="key">SPC</kbd></kbd></dt>
<dd><p>Toggle Rectangle Mark mode (<code class="code">rectangle-mark-mode</code>).
When this mode is active, the region-rectangle is highlighted and can
be shrunk/grown, and the standard kill and yank commands operate on it.
</p></dd>
</dl>

<p>The rectangle operations fall into two classes: commands to erase or
insert rectangles, and commands to make blank rectangles.
</p>
<a class="index-entry-id" id="index-C_002dx-r-k"></a>
<a class="index-entry-id" id="index-C_002dx-r-d"></a>
<a class="index-entry-id" id="index-kill_002drectangle"></a>
<a class="index-entry-id" id="index-delete_002drectangle"></a>
<p>There are two ways to erase the text in a rectangle: <kbd class="kbd">C-x r d</kbd>
(<code class="code">delete-rectangle</code>) to delete the text outright, or <kbd class="kbd">C-x r
k</kbd> (<code class="code">kill-rectangle</code>) to remove the text and save it as the
<em class="dfn">last killed rectangle</em>.  In both cases, erasing the
region-rectangle is like erasing the specified text on each line of
the rectangle; if there is any following text on the line, it moves
backwards to fill the gap.
</p>
<p>Killing a rectangle is not killing in the usual sense; the
rectangle is not stored in the kill ring, but in a special place that
only records the most recent rectangle killed.  This is because
yanking a rectangle is so different from yanking linear text that
different yank commands have to be used.  Yank-popping is not defined
for rectangles.
</p>
<a class="index-entry-id" id="index-C_002dx-r-M_002dw"></a>
<a class="index-entry-id" id="index-copy_002drectangle_002das_002dkill"></a>
<p><kbd class="kbd">C-x r M-w</kbd> (<code class="code">copy-rectangle-as-kill</code>) is the equivalent of
<kbd class="kbd">M-w</kbd> for rectangles: it records the rectangle as the last
killed rectangle, without deleting the text from the buffer.
</p>
<a class="index-entry-id" id="index-C_002dx-r-y"></a>
<a class="index-entry-id" id="index-yank_002drectangle"></a>
<p>To yank the last killed rectangle, type <kbd class="kbd">C-x r y</kbd>
(<code class="code">yank-rectangle</code>).  The rectangle&#8217;s first line is inserted at
point, the rectangle&#8217;s second line is inserted at the same horizontal
position one line vertically below, and so on.  The number of lines
affected is determined by the height of the saved rectangle.
</p>
<p>For example, you can convert two single-column lists into a
double-column list by killing one of the single-column lists as a
rectangle, and then yanking it beside the other list.
</p>
<p>You can also copy rectangles into and out of registers with <kbd class="kbd">C-x r
r <var class="var">r</var></kbd> and <kbd class="kbd">C-x r i <var class="var">r</var></kbd>.  See <a class="xref" href="Registers.xhtml#Rectangle-Registers">Saving Rectangles in Registers</a>.
</p>
<a class="index-entry-id" id="index-C_002dx-r-o"></a>
<a class="index-entry-id" id="index-open_002drectangle"></a>
<a class="index-entry-id" id="index-C_002dx-r-c"></a>
<a class="index-entry-id" id="index-clear_002drectangle"></a>
<p>There are two commands you can use for making blank rectangles:
<kbd class="kbd">C-x r c</kbd> (<code class="code">clear-rectangle</code>) blanks out existing text in the
region-rectangle, and <kbd class="kbd">C-x r o</kbd> (<code class="code">open-rectangle</code>) inserts a
blank rectangle.
</p>
<a class="index-entry-id" id="index-delete_002dwhitespace_002drectangle"></a>
<p><kbd class="kbd">M-x delete-whitespace-rectangle</kbd> deletes horizontal whitespace
starting from a particular column.  This applies to each of the lines
in the rectangle, and the column is specified by the left edge of the
rectangle.  The right edge of the rectangle does not make any
difference to this command.
</p>
<a class="index-entry-id" id="index-C_002dx-r-N"></a>
<a class="index-entry-id" id="index-rectangle-1"></a>
<p>The command <kbd class="kbd">C-x r N</kbd> (<code class="code">rectangle-number-lines</code>) inserts
line numbers along the left edge of the region-rectangle.  Normally,
the numbering begins from 1 (for the first line of the rectangle).
With a prefix argument, the command prompts for a number to begin
from, and for a format string with which to print the numbers
(see <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Formatting-Strings.html#Formatting-Strings">Formatting Strings</a> in <cite class="cite">The Emacs Lisp Reference
Manual</cite>).
</p>
<a class="index-entry-id" id="index-C_002dx-r-t"></a>
<a class="index-entry-id" id="index-string_002drectangle"></a>
<p>The command <kbd class="kbd">C-x r t</kbd> (<code class="code">string-rectangle</code>) replaces the
contents of a region-rectangle with a string on each line.  The
string&#8217;s width need not be the same as the width of the rectangle.  If
the string&#8217;s width is less, the text after the rectangle shifts left;
if the string is wider than the rectangle, the text after the
rectangle shifts right.
</p>
<a class="index-entry-id" id="index-string_002dinsert_002drectangle"></a>
<p>The command <kbd class="kbd">M-x string-insert-rectangle</kbd> is similar to
<code class="code">string-rectangle</code>, but inserts the string on each line,
shifting the original text to the right.
</p>
<a class="index-entry-id" id="index-rectangle_002dmark_002dmode"></a>
<p>The command <kbd class="kbd">C-x <kbd class="key">SPC</kbd></kbd> (<code class="code">rectangle-mark-mode</code>) toggles
whether the region-rectangle or the standard region is highlighted
(first activating the region if necessary).  When this mode is enabled,
commands that resize the region (<kbd class="kbd">C-f</kbd>, <kbd class="kbd">C-n</kbd> etc.) do
so in a rectangular fashion, and killing and yanking operate on the
rectangle.  See <a class="xref" href="#Killing">Killing and Moving Text</a>.  The mode persists only as long as the
region is active.
</p>
<p>The region-rectangle works only when the mark is active.  In
particular, when Transient Mark mode is off (see <a class="pxref" href="Mark.xhtml#Disabled-Transient-Mark">Disabling Transient Mark Mode</a>), in addition to typing <kbd class="kbd">C-x <kbd class="key">SPC</kbd></kbd> you will need to
activate the mark.
</p>
<p>Unlike the standard region, the region-rectangle can have its corners
extended past the end of buffer, or inside stretches of white space
that point normally cannot enter, like in the middle of a TAB
character.
</p>
<a class="index-entry-id" id="index-rectangle_002dexchange_002dpoint_002dand_002dmark"></a>
<a class="index-entry-id" id="index-exchange_002dpoint_002dand_002dmark_002c-in-rectangle_002dmark_002dmode"></a>
<a class="index-entry-id" id="index-C_002dx-C_002dx_002c-in-rectangle_002dmark_002dmode"></a>
<p>When the region is active (see <a class="pxref" href="Mark.xhtml#Mark">The Mark and the Region</a>) and in rectangle-mark-mode,
<kbd class="kbd">C-x C-x</kbd> runs the command
<code class="code">rectangle-exchange-point-and-mark</code>, which cycles between the
four corners of the region-rectangle.  This comes in handy if you want
to modify the dimensions of the region-rectangle before invoking an
operation on the marked text.
</p>
</div>
<div class="section-level-extent" id="CUA-Bindings">
<h3 class="section" id="CUA-Bindings-1">13.6 CUA Bindings</h3>
<a class="index-entry-id" id="index-cua_002dmode"></a>
<a class="index-entry-id" id="index-cua_002dmode-1"></a>
<a class="index-entry-id" id="index-CUA-key-bindings"></a>
<a class="index-entry-id" id="index-cua_002denable_002dcua_002dkeys"></a>
<p>The command <kbd class="kbd">M-x cua-mode</kbd> sets up key bindings that are
compatible with the Common User Access (CUA) system used in many other
applications.
</p>
<p>When CUA mode is enabled, the keys <kbd class="kbd">C-x</kbd>, <kbd class="kbd">C-c</kbd>, <kbd class="kbd">C-v</kbd>,
and <kbd class="kbd">C-z</kbd> invoke commands that cut (kill), copy, paste (yank), and
undo respectively.  The <kbd class="kbd">C-x</kbd> and <kbd class="kbd">C-c</kbd> keys perform cut and
copy only if the region is active.  Otherwise, they still act as
prefix keys, so that standard Emacs commands like <kbd class="kbd">C-x C-c</kbd> still
work.  Note that this means the variable <code class="code">mark-even-if-inactive</code>
has no effect for <kbd class="kbd">C-x</kbd> and <kbd class="kbd">C-c</kbd> (see <a class="pxref" href="Mark.xhtml#Using-Region">Operating on the Region</a>).
</p>
<p>To enter an Emacs command like <kbd class="kbd">C-x C-f</kbd> while the mark is
active, use one of the following methods: either hold <kbd class="kbd">Shift</kbd>
together with the prefix key, e.g., <kbd class="kbd">S-C-x C-f</kbd>, or quickly type
the prefix key twice, e.g., <kbd class="kbd">C-x C-x C-f</kbd>.
</p>
<p>To disable the overriding of standard Emacs binding by CUA mode,
while retaining the other features of CUA mode described below, set
the variable <code class="code">cua-enable-cua-keys</code> to <code class="code">nil</code>.
</p>
<p>CUA mode by default activates Delete-Selection mode (see <a class="pxref" href="Frames.xhtml#Mouse-Commands">Mouse Commands for Editing</a>)
so that typed text replaces the active region.  To use CUA without this
behavior, set the variable <code class="code">cua-delete-selection</code> to <code class="code">nil</code>.
</p>
<a class="index-entry-id" id="index-rectangle-highlighting"></a>
<p>CUA mode provides enhanced rectangle support with visible
rectangle highlighting.  Use <kbd class="kbd">C-<kbd class="key">RET</kbd></kbd> to start a rectangle,
extend it using the movement commands, and cut or copy it using
<kbd class="kbd">C-x</kbd> or <kbd class="kbd">C-c</kbd>.  <kbd class="key">RET</kbd> moves the cursor to the next
(clockwise) corner of the rectangle, so you can easily expand it in
any direction.  Normal text you type is inserted to the left or right
of each line in the rectangle (on the same side as the cursor).
</p>
<p>You can use this rectangle support without activating CUA by calling the
<code class="code">cua-rectangle-mark-mode</code> command.  There&#8217;s also the standard command
<code class="code">rectangle-mark-mode</code>, see <a class="ref" href="#Rectangles">Rectangles</a>.
</p>
<p>With CUA you can easily copy text and rectangles into and out of
registers by providing a one-digit numeric prefix to the kill, copy,
and yank commands, e.g., <kbd class="kbd">C-1 C-c</kbd> copies the region into register
<code class="code">1</code>, and <kbd class="kbd">C-2 C-v</kbd> yanks the contents of register <code class="code">2</code>.
</p>
<a class="index-entry-id" id="index-global-mark"></a>
<p>CUA mode also has a global mark feature which allows easy moving and
copying of text between buffers.  Use <kbd class="kbd">C-S-<kbd class="key">SPC</kbd></kbd> to toggle the
global mark on and off.  When the global mark is on, all text that you
kill or copy is automatically inserted at the global mark, and text
you type is inserted at the global mark rather than at the current
position.
</p>
<p>For example, to copy words from various buffers into a word list in
a given buffer, set the global mark in the target buffer, then
navigate to each of the words you want in the list, mark it (e.g., with
<kbd class="kbd">S-M-f</kbd>), copy it to the list with <kbd class="kbd">C-c</kbd> or <kbd class="kbd">M-w</kbd>, and
insert a newline after the word in the target list by pressing
<kbd class="key">RET</kbd>.
</p></div>
</div>



</body>
</html>
