<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- 这是 GNU Emacs 手册,
为 Emacs  29.2 更新

英文原版版权提示 - Original English version copyright note

Copyright © 1985-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "The GNU Manifesto," "Distribution" and
"GNU GENERAL PUBLIC LICENSE," with the Front-Cover Texts being "A GNU
Manual," and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."

中文翻译版版权提示 - Chinese translation revision copyright notice

版权所有 © 1985-2024 林羿轩(Ralph Lin).

您有在 Free Software Foundation发布的GNU Free Documentation License 第1.3版或之后版本的约束下对其进行再发布及修的权利。 恒定章节为 "The GNU Manifesto," "分发" "(中文版)GNU GENERAL PUBLIC LICENSE" 和
"GNU GENERAL PUBLIC LICENSE" , 前封面文字为 "A GNU
Manual,"后封面文字如下(a).  本书的FDL许可证可以在 "GNU Free Documentation
License."找到.

(a) FSF的后封面文字为: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."
 -->
<title>16 Searching and Replacement (GNU Emacs Manual)</title>

<meta name="description" content="16 Searching and Replacement (GNU Emacs Manual)"/>
<meta name="keywords" content="16 Searching and Replacement (GNU Emacs Manual)"/>
<meta name="resource-type" content="document"/>
<meta name="distribution" content="global"/>
<meta name="Generator" content="texi2any"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>

<link href="emacs.xhtml" rel="start" title="Emacs 编辑器"/>
<link href="Key-Index.xhtml" rel="index" title="Key (Character) Index"/>
<link href="emacs.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="emacs.xhtml" rel="up" title="Emacs 编辑器"/>
<link href="Fixit.xhtml#Fixit" rel="next" title="17 Commands for Fixing Typos"/>
<link href="Display.xhtml#Display" rel="prev" title="15 Controlling the Display"/>
<style type="text/css">
<!--
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
kbd.key {font-style: normal}
span.r {font-family: initial; font-weight: normal; font-style: normal}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="zh_CN">
<div class="chapter-level-extent" id="Search">

<h2 class="chapter" id="Searching-and-Replacement">16 Searching and Replacement</h2>
<a class="index-entry-id" id="index-searching"></a>
<a class="index-entry-id" id="index-finding-strings-within-text"></a>

<p>Like other editors, Emacs has commands to search for occurrences of
a string.  Emacs also has commands to replace occurrences of a string
with a different string.  There are also commands that do the same
thing, but search for patterns instead of fixed strings.
</p>
<p>You can also search multiple files under the control of <code class="code">xref</code>
(see <a class="pxref" href="Maintaining.xhtml#Identifier-Search">Searching and Replacing with Identifiers</a>) or through the Dired <kbd class="kbd">A</kbd> command
(see <a class="pxref" href="Dired.xhtml#Operating-on-Files">Operating on Files</a>), or ask the <code class="code">grep</code> program to do it
(see <a class="pxref" href="Building.xhtml#Grep-Searching">Searching with Grep under Emacs</a>).
</p>

<div class="section-level-extent" id="Incremental-Search">
<h3 class="section" id="Incremental-Search-1">16.1 Incremental Search</h3>
<a class="index-entry-id" id="index-incremental-search"></a>
<a class="index-entry-id" id="index-isearch"></a>

<p>The principal search command in Emacs is <em class="dfn">incremental</em>: it
begins searching as soon as you type the first character of the search
string.  As you type in the search string, Emacs shows you where the
string (as you have typed it so far) would be found.  When you have
typed enough characters to identify the place you want, you can stop.
Depending on what you plan to do next, you may or may not need to
terminate the search explicitly with <kbd class="key">RET</kbd>.
</p>
<dl class="table">
<dt><kbd class="kbd">C-s</kbd></dt>
<dd><p>Incremental search forward (<code class="code">isearch-forward</code>).
</p></dd>
<dt><kbd class="kbd">C-r</kbd></dt>
<dd><p>Incremental search backward (<code class="code">isearch-backward</code>).
</p></dd>
</dl>

<p>You can also invoke incremental search from the menu bar&#8217;s
&#8216;<samp class="samp">Edit-&gt;Search</samp>&#8217; menu.
</p>

<div class="subsection-level-extent" id="Basic-Isearch">
<h4 class="subsection" id="Basics-of-Incremental-Search">16.1.1 Basics of Incremental Search</h4>

<dl class="table">
<dt><kbd class="kbd">C-s</kbd></dt>
<dd><p>Begin incremental search (<code class="code">isearch-forward</code>).
</p></dd>
<dt><kbd class="kbd">C-r</kbd></dt>
<dd><p>Begin reverse incremental search (<code class="code">isearch-backward</code>).
</p></dd>
</dl>

<a class="index-entry-id" id="index-C_002ds"></a>
<a class="index-entry-id" id="index-isearch_002dforward"></a>
<p><kbd class="kbd">C-s</kbd> (<code class="code">isearch-forward</code>) starts a forward incremental
search.  It reads characters from the keyboard, and moves point just
past the end of the next occurrence of those characters in the buffer.
</p>
<p>For instance, if you type <kbd class="kbd">C-s</kbd> and then <kbd class="kbd">F</kbd>, that puts the
cursor after the first &#8216;<samp class="samp">F</samp>&#8217; that occurs in the buffer after the
starting point.  If you then type <kbd class="kbd">O</kbd>, the cursor moves to just
after the first &#8216;<samp class="samp">FO</samp>&#8217;; the &#8216;<samp class="samp">F</samp>&#8217; in that &#8216;<samp class="samp">FO</samp>&#8217; might not be
the first &#8216;<samp class="samp">F</samp>&#8217; previously found.  After another <kbd class="kbd">O</kbd>, the
cursor moves to just after the first &#8216;<samp class="samp">FOO</samp>&#8217;.
</p>
<a class="index-entry-id" id="index-faces-for-highlighting-search-matches"></a>
<a class="index-entry-id" id="index-isearch-face"></a>
<p>At each step, Emacs highlights the <em class="dfn">current match</em>&#8212;the buffer
text that matches the search string&#8212;using the <code class="code">isearch</code> face
(see <a class="pxref" href="Display.xhtml#Faces">Text Faces</a>).  See <a class="xref" href="#Search-Customizations">Tailoring Search to Your Needs</a>, for various options
that customize this highlighting.  The current search string is also
displayed in the echo area.
</p>
<a class="index-entry-id" id="index-isearch-input-item"></a>
<a class="index-entry-id" id="index-input-item_002c-isearch"></a>
<a class="index-entry-id" id="index-isearch_002ddelete_002dchar"></a>
<a class="index-entry-id" id="index-DEL-_0028Incremental-search_0029"></a>
<p>If you make a mistake typing the search string, type <kbd class="key">DEL</kbd>
(<code class="code">isearch-delete-char</code>).  Each <kbd class="key">DEL</kbd> cancels the last input
item entered during the search.  Emacs records a new <em class="dfn">input item</em>
whenever you type a command that changes the search string, the
position of point, the success or failure of the search, the direction
of the search, the position of the other end of the current search
result, or the &#8220;wrappedness&#8221; of the search.  See <a class="xref" href="#Error-in-Isearch">Errors in Incremental Search</a>, for more about dealing with unsuccessful search.
</p>
<a class="index-entry-id" id="index-exit-incremental-search"></a>
<a class="index-entry-id" id="index-incremental-search_002c-exiting"></a>
<a class="index-entry-id" id="index-isearch_002dexit"></a>
<a class="index-entry-id" id="index-RET-_0028Incremental-search_0029"></a>
<p>When you are satisfied with the place you have reached, type
<kbd class="key">RET</kbd> (<code class="code">isearch-exit</code>).  This stops searching, leaving the
cursor where the search brought it.  Also, any command not specially
meaningful in searches stops the searching and is then executed.
Thus, typing <kbd class="kbd">C-a</kbd> exits the search and then moves to the
beginning of the line; typing one of the arrow keys exits the search
and performs the respective movement command; etc.  <kbd class="key">RET</kbd> is
necessary only if the next command you want to type is a printing
character, <kbd class="key">DEL</kbd>, <kbd class="key">RET</kbd>, or another character that is special
within searches (<kbd class="kbd">C-q</kbd>, <kbd class="kbd">C-w</kbd>, <kbd class="kbd">C-r</kbd>, <kbd class="kbd">C-s</kbd>,
<kbd class="kbd">C-y</kbd>, <kbd class="kbd">M-y</kbd>, <kbd class="kbd">M-r</kbd>, <kbd class="kbd">M-c</kbd>, <kbd class="kbd">M-e</kbd>, and some others
described below).  You can fine-tune the commands that exit the
search; see <a class="ref" href="#Not-Exiting-Isearch">Not Exiting Incremental Search</a>.
</p>
<p>As a special exception, entering <kbd class="key">RET</kbd> when the search string is
empty launches nonincremental search (see <a class="pxref" href="#Nonincremental-Search">Nonincremental Search</a>).
(This can be customized; see <a class="ref" href="#Search-Customizations">Tailoring Search to Your Needs</a>.)
</p>
<a class="index-entry-id" id="index-isearch_002dabort"></a>
<a class="index-entry-id" id="index-isearch_002dcancel"></a>
<a class="index-entry-id" id="index-C_002dg-C_002dg-_0028Incremental-Search_0029"></a>
<a class="index-entry-id" id="index-ESC-ESC-ESC-_0028Incremental-Search_0029"></a>
<p>To abandon the search and return to the place where you started,
type <kbd class="kbd"><kbd class="key">ESC</kbd> <kbd class="key">ESC</kbd> <kbd class="key">ESC</kbd></kbd> (<code class="code">isearch-cancel</code>) or
<kbd class="kbd">C-g C-g</kbd> (<code class="code">isearch-abort</code>).
</p>
<p>When you exit the incremental search, it adds the original value of
point to the mark ring, without activating the mark; you can thus use
<kbd class="kbd">C-u C-<kbd class="key">SPC</kbd></kbd> or <kbd class="kbd">C-x C-x</kbd> to return to where you were
before beginning the search.  See <a class="xref" href="Mark.xhtml#Mark-Ring">The Mark Ring</a>.  (Emacs only does this
if the mark was not already active; if the mark was active when you
started the search, both <kbd class="kbd">C-u C-<kbd class="key">SPC</kbd></kbd> and <kbd class="kbd">C-x C-x</kbd> will
go to the mark.)
</p>
<a class="index-entry-id" id="index-C_002dr"></a>
<a class="index-entry-id" id="index-isearch_002dbackward"></a>
<p>To search backwards, use <kbd class="kbd">C-r</kbd> (<code class="code">isearch-backward</code>) instead
of <kbd class="kbd">C-s</kbd> to start the search.  A backward search finds matches
that end before the starting point, just as a forward search finds
matches that begin after it.
</p>
</div>
<div class="subsection-level-extent" id="Repeat-Isearch">
<h4 class="subsection" id="Repeating-Incremental-Search">16.1.2 Repeating Incremental Search</h4>

<a class="index-entry-id" id="index-C_002ds-_0028Incremental-Search_0029"></a>
<a class="index-entry-id" id="index-C_002dr-_0028Incremental-Search_0029"></a>
<a class="index-entry-id" id="index-isearch_002drepeat_002dforward"></a>
<a class="index-entry-id" id="index-isearch_002drepeat_002dbackward"></a>
<p>Suppose you search forward for &#8216;<samp class="samp">FOO</samp>&#8217; and find a match, but not
the one you expected to find: the &#8216;<samp class="samp">FOO</samp>&#8217; you were aiming for
occurs later in the buffer.  In this event, type another <kbd class="kbd">C-s</kbd>
(<code class="code">isearch-repeat-forward</code>) to move to the next occurrence of the
search string, or <kbd class="kbd">C-r</kbd> (<code class="code">isearch-repeat-backward</code>) to move
to the previous occurrence.  You can repeat these commands any number
of times.  Alternatively, you can supply a numeric prefix argument of
<var class="var">n</var> to <kbd class="kbd">C-s</kbd> and <kbd class="kbd">C-r</kbd> to find the <var class="var">n</var>th next or
previous occurrence.  If you overshoot, you can cancel some <kbd class="kbd">C-s</kbd>
commands with <kbd class="key">DEL</kbd>.  Similarly, each <kbd class="kbd">C-r</kbd>
(<code class="code">isearch-repeat-backward</code>) in a backward incremental search
repeats the backward search.
</p>
<a class="index-entry-id" id="index-lazy-search-highlighting"></a>
<p>If you pause for a little while during incremental search, Emacs
highlights all the other possible matches for the search string that
are present on the screen.  This helps you anticipate where you can
get to by typing <kbd class="kbd">C-s</kbd> or <kbd class="kbd">C-r</kbd> to repeat the search.  The
other matches are highlighted differently from the current match,
using the customizable face <code class="code">lazy-highlight</code> (see <a class="pxref" href="Display.xhtml#Faces">Text Faces</a>).  If
you don&#8217;t like this feature, you can disable it by setting
<code class="code">isearch-lazy-highlight</code> to <code class="code">nil</code>.  For other customizations
related to highlighting matches, see <a class="ref" href="#Search-Customizations">Tailoring Search to Your Needs</a>.
</p>
<p>After exiting a search, you can search for the same string again by
typing just <kbd class="kbd">C-s C-s</kbd>.  The first <kbd class="kbd">C-s</kbd> is the key that
invokes incremental search, and the second <kbd class="kbd">C-s</kbd> means to search
again for the last search string.  Similarly, <kbd class="kbd">C-r C-r</kbd> searches
backward for the last search string.  In determining the last search
string, it doesn&#8217;t matter whether that string was searched for with
<kbd class="kbd">C-s</kbd> or <kbd class="kbd">C-r</kbd>.
</p>
<p>If you are searching forward but you realize you were looking for
something before the starting point, type <kbd class="kbd">C-r</kbd> to switch to a
backward search, leaving the search string unchanged.  Similarly,
<kbd class="kbd">C-s</kbd> in a backward search switches to a forward search.
</p>
<a class="index-entry-id" id="index-search_002c-changing-direction"></a>
<a class="index-entry-id" id="index-isearch_002drepeat_002don_002ddirection_002dchange"></a>
<p>When you change the direction of a search, the first command you
type will, by default, remain on the same match, and the cursor will
move to the other end of the match.  To move to another match
immediately, customize the variable
<code class="code">isearch-repeat-on-direction-change</code> to <code class="code">t</code>.
</p>
<a class="index-entry-id" id="index-search_002c-wrapping-around"></a>
<a class="index-entry-id" id="index-search_002c-overwrapped"></a>
<a class="index-entry-id" id="index-wrapped-search"></a>
<a class="index-entry-id" id="index-overwrapped-search"></a>
<p>If a search is failing and you ask to repeat it by typing another
<kbd class="kbd">C-s</kbd>, it starts again from the beginning of the buffer.
Repeating a failing reverse search with <kbd class="kbd">C-r</kbd> starts again from
the end.  This is called <em class="dfn">wrapping around</em>, and &#8216;<samp class="samp">Wrapped</samp>&#8217;
appears in the search prompt once this has happened.  If you keep on
going past the original starting point of the search, it changes to
&#8216;<samp class="samp">Overwrapped</samp>&#8217;, which means that you are revisiting matches that
you have already seen.
</p>
<a class="index-entry-id" id="index-isearch_002dwrap_002dpause"></a>
<p>You can control what happens when there are no more matches by
customizing the <code class="code">isearch-wrap-pause</code> user option.  If it is
<code class="code">t</code> (the default), signal an error.  (Repeating the search will
wrap around.)  If <code class="code">no</code>, issue a <code class="code">ding</code> and wrap immediately
after reaching the last match.  If <code class="code">no-ding</code>, wrap immediately,
but don&#8217;t <code class="code">ding</code>.  With the values <code class="code">no</code> and <code class="code">no-ding</code>
the search will try to wrap around also on typing a character.
Finally, if <code class="code">nil</code>, never wrap, but just stop at the last match.
</p>
<a class="index-entry-id" id="index-search-ring"></a>
<a class="index-entry-id" id="index-isearch_002dring_002dadvance"></a>
<a class="index-entry-id" id="index-isearch_002dring_002dretreat"></a>
<a class="index-entry-id" id="index-M_002dn-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-M_002dp-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-search_002dring_002dmax"></a>
<p>To reuse earlier search strings, use the <em class="dfn">search ring</em>.  The
commands <kbd class="kbd">M-p</kbd> (<code class="code">isearch-ring-retreat</code>) and <kbd class="kbd">M-n</kbd>
(<code class="code">isearch-ring-advance</code>) move through the ring to pick a search
string to reuse.  These commands leave the selected search ring
element in the minibuffer, where you can edit it.  Type
<kbd class="kbd">C-s</kbd>/<kbd class="kbd">C-r</kbd> or <kbd class="key">RET</kbd> to accept the string and start
searching for it.  The number of most recently used search strings
saved in the search ring is specified by the variable
<code class="code">search-ring-max</code>, 16 by default.
</p>
<a class="index-entry-id" id="index-incremental-search_002c-edit-search-string"></a>
<a class="index-entry-id" id="index-interactively-edit-search-string"></a>
<a class="index-entry-id" id="index-isearch_002dedit_002dstring"></a>
<a class="index-entry-id" id="index-M_002de-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-mouse_002d1-in-the-minibuffer-_0028Incremental-Search_0029"></a>
<p>To edit the current search string in the minibuffer without
replacing it with items from the search ring, type <kbd class="kbd">M-e</kbd>
(<code class="code">isearch-edit-string</code>) or click <kbd class="kbd">mouse-1</kbd> in the minibuffer.
Type <kbd class="key">RET</kbd>, <kbd class="kbd">C-s</kbd> or <kbd class="kbd">C-r</kbd> to finish editing the string
and search for it.  Type <kbd class="kbd">C-f</kbd> or <kbd class="kbd"><kbd class="key">RIGHT</kbd></kbd> to add to the
search string characters following point from the buffer from which
you started the search.
</p>
</div>
<div class="subsection-level-extent" id="Isearch-Yank">
<h4 class="subsection" id="Isearch-Yanking">16.1.3 Isearch Yanking</h4>

<p>In many cases, you will want to use text at or near point as your
search string.  The commands described in this subsection let you do
that conveniently.
</p>
<a class="index-entry-id" id="index-C_002dw-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dyank_002dword_002dor_002dchar"></a>
<p><kbd class="kbd">C-w</kbd> (<code class="code">isearch-yank-word-or-char</code>) appends the next
character or word at point to the search string.  This is an easy way
to search for another occurrence of the text at point.  (The decision
of whether to copy a character or a word is heuristic.)  With a prefix
numeric argument of <var class="var">n</var>, append the next <var class="var">n</var> characters or
words.
</p>
<a class="index-entry-id" id="index-C_002dM_002dw-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dyank_002dsymbol_002dor_002dchar"></a>
<p><kbd class="kbd">C-M-w</kbd> (<code class="code">isearch-yank-symbol-or-char</code>) appends the next
character or symbol at point to the search string.  This is an easy way
to search for another occurrence of the symbol at point.  (The decision
of whether to copy a character or a symbol is heuristic.)  With a prefix
numeric argument of <var class="var">n</var>, append the next <var class="var">n</var> characters or
symbols.
</p>
<a class="index-entry-id" id="index-M_002ds-C_002de-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dyank_002dline"></a>
<p><kbd class="kbd">M-s C-e</kbd> (<code class="code">isearch-yank-line</code>) appends the rest
of the current line to the search string.  If point is already at the
end of a line, it appends the next line.  With a prefix argument
<var class="var">n</var>, it appends the next <var class="var">n</var> lines.
</p>
<a class="index-entry-id" id="index-C_002dM_002dz-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dyank_002duntil_002dchar"></a>
<p>Similarly, <kbd class="kbd">C-M-z</kbd> (<code class="code">isearch-yank-until-char</code>) appends to
the search string everything from point until the next occurrence of
a specified character (not including that character).  This is especially
useful for keyboard macros, for example in programming languages or
markup languages in which that character marks a token boundary.  With
a prefix numeric argument of <var class="var">n</var>, the command appends everything
from point to the <var class="var">n</var>th occurrence of the specified character.
</p>
<a class="index-entry-id" id="index-C_002dy-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-M_002dy-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-mouse_002d2-in-the-minibuffer-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dyank_002dkill"></a>
<a class="index-entry-id" id="index-isearch_002dyank_002dpop"></a>
<a class="index-entry-id" id="index-isearch_002dyank_002dx_002dselection"></a>
<p>Within incremental search, <kbd class="kbd">C-y</kbd> (<code class="code">isearch-yank-kill</code>)
appends the current kill to the search string.  <kbd class="kbd">M-y</kbd>
(<code class="code">isearch-yank-pop</code>), if called after <kbd class="kbd">C-y</kbd> during
incremental search, replaces that appended text with an earlier kill,
similar to the usual <kbd class="kbd">M-y</kbd> (<code class="code">yank-pop</code>) command.  Clicking
<kbd class="kbd">mouse-2</kbd> in the echo area appends the current X selection
(see <a class="pxref" href="Killing.xhtml#Primary-Selection">Cut and Paste with Other Window Applications</a>) to the search string
(<code class="code">isearch-yank-x-selection</code>).
</p>
<a class="index-entry-id" id="index-C_002dM_002dd-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-C_002dM_002dy-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-isearch_002ddel_002dchar"></a>
<a class="index-entry-id" id="index-isearch_002dyank_002dchar"></a>
<p><kbd class="kbd">C-M-d</kbd> (<code class="code">isearch-del-char</code>) deletes the last character
from the search string, and <kbd class="kbd">C-M-y</kbd> (<code class="code">isearch-yank-char</code>)
appends the character after point to the search string.  An
alternative method to add the character after point is to enter the
minibuffer with <kbd class="kbd">M-e</kbd> (see <a class="pxref" href="#Repeat-Isearch">Repeating Incremental Search</a>) and type <kbd class="kbd">C-f</kbd>
or <kbd class="kbd"><kbd class="key">RIGHT</kbd></kbd> at the end of the search string in the
minibuffer.  Each <kbd class="kbd">C-f</kbd> or <kbd class="kbd"><kbd class="key">RIGHT</kbd></kbd> you type adds another
character following point to the search string.
</p>
<p>Normally, when the search is case-insensitive, text yanked into the
search string is converted to lower case, so that the search remains
case-insensitive (see <a class="pxref" href="#Lax-Search">case folding</a>).  However, if the
value of the variable <code class="code">search-upper-case</code> (see <a class="pxref" href="#Lax-Search">search-upper-case</a>) is other than <code class="code">not-yanks</code>, that disables this
down-casing.
</p>
<a class="index-entry-id" id="index-M_002ds-M_002d_002e"></a>
<a class="index-entry-id" id="index-isearch_002dforward_002dthing_002dat_002dpoint"></a>
<p>To begin a new incremental search with the text near point yanked
into the initial search string, type <kbd class="kbd">M-s M-.</kbd> that runs the
command <code class="code">isearch-forward-thing-at-point</code>.  If the region was
active, then it yanks the text from the region into the search string.
Otherwise, it tries to yank a URL, a symbol or an expression found
near point.  What to yank is defined by the user option
<code class="code">isearch-forward-thing-at-point</code>.
</p>
</div>
<div class="subsection-level-extent" id="Error-in-Isearch">
<h4 class="subsection" id="Errors-in-Incremental-Search">16.1.4 Errors in Incremental Search</h4>

<a class="index-entry-id" id="index-isearch_002dfail-face"></a>
<p>If your string is not found at all, the echo area says &#8216;<samp class="samp">Failing
I-Search</samp>&#8217;, and the cursor moves past the place where Emacs found as
much of your string as it could.  Thus, if you search for &#8216;<samp class="samp">FOOT</samp>&#8217;,
and there is no &#8216;<samp class="samp">FOOT</samp>&#8217;, you might see the cursor after the
&#8216;<samp class="samp">FOO</samp>&#8217; in &#8216;<samp class="samp">FOOL</samp>&#8217;.  In the echo area, the part of the search
string that failed to match is highlighted using the face
<code class="code">isearch-fail</code>.
</p>
<p>At this point, there are several things you can do.  If your string
was mistyped, use <kbd class="key">DEL</kbd> to cancel a previous input item
(see <a class="pxref" href="#Basic-Isearch">Basics of Incremental Search</a>), <kbd class="kbd">C-M-d</kbd> to erase one character at a time,
or <kbd class="kbd">M-e</kbd> to edit it.  If you like the place you have found, you
can type <kbd class="key">RET</kbd> to remain there.  Or you can type <kbd class="kbd">C-g</kbd>, which
removes from the search string the characters that could not be found
(the &#8216;<samp class="samp">T</samp>&#8217; in &#8216;<samp class="samp">FOOT</samp>&#8217;), leaving those that were found (the
&#8216;<samp class="samp">FOO</samp>&#8217; in &#8216;<samp class="samp">FOOT</samp>&#8217;).  A second <kbd class="kbd">C-g</kbd> at that point cancels
the search entirely, returning point to where it was when the search
started.
</p>
<a class="index-entry-id" id="index-quitting-_0028in-search_0029"></a>
<a class="index-entry-id" id="index-C_002dg-_0028Incremental-search_0029"></a>
<p>The quit command, <kbd class="kbd">C-g</kbd>, does special things during searches;
just what it does depends on the status of the search.  If the search
has found what you specified and is waiting for input, <kbd class="kbd">C-g</kbd>
cancels the entire search, moving the cursor back to where you started
the search.  If <kbd class="kbd">C-g</kbd> is typed when there are characters in the
search string that have not been found&#8212;because Emacs is still
searching for them, or because it has failed to find them&#8212;then the
search string characters which have not been found are discarded from
the search string.  With them gone, the search is now successful and
waiting for more input, so a second <kbd class="kbd">C-g</kbd> will cancel the entire
search.
</p>
</div>
<div class="subsection-level-extent" id="Special-Isearch">
<h4 class="subsection" id="Special-Input-for-Incremental-Search">16.1.5 Special Input for Incremental Search</h4>

<p>In addition to characters described in the previous subsections,
some of the other characters you type during incremental search have
special effects.  They are described here.
</p>
<p>To toggle lax space matching (see <a class="pxref" href="#Lax-Search">lax space
matching</a>), type <kbd class="kbd">M-s <kbd class="key">SPC</kbd></kbd>.
</p>
<p>To toggle case sensitivity of the search, type <kbd class="kbd">M-c</kbd> or
<kbd class="kbd">M-s c</kbd>.  See <a class="xref" href="#Lax-Search">case folding</a>.  If the search string
includes upper-case letters, the search is case-sensitive by default.
</p>
<p>To toggle whether or not the search will consider similar and
equivalent characters as a match, type <kbd class="kbd">M-s '</kbd>.  See <a class="xref" href="#Lax-Search">character folding</a>.  If the search string includes accented
characters, that disables character folding during that search.
</p>
<a class="index-entry-id" id="index-invisible-text_002c-searching-for"></a>
<a class="index-entry-id" id="index-M_002ds-i-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dtoggle_002dinvisible"></a>
<p>To toggle whether or not the search will find text made invisible by
overlays, type <kbd class="kbd">M-s i</kbd> (<code class="code">isearch-toggle-invisible</code>).
See <a class="xref" href="Text.xhtml#Outline-Search">Outline Search</a>.  To make all incremental searches find matches
inside invisible text, whether due to text properties or overlay
properties, customize <code class="code">search-invisible</code> to the value <code class="code">t</code>.
</p>
<a class="index-entry-id" id="index-M_002dr-_0028Incremental-Search_0029"></a>
<a class="index-entry-id" id="index-M_002ds-r-_0028Incremental-Search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dtoggle_002dregexp"></a>
<p>To toggle between non-regexp and regexp incremental search, type
<kbd class="kbd">M-r</kbd> or <kbd class="kbd">M-s r</kbd> (<code class="code">isearch-toggle-regexp</code>).
See <a class="xref" href="#Regexp-Search">Regular Expression Search</a>.
</p>
<p>To toggle symbol mode, type <kbd class="kbd">M-s _</kbd>.  See <a class="xref" href="#Symbol-Search">Symbol Search</a>.
</p>
<p>To search for a newline character, type <kbd class="kbd">C-j</kbd> as part of the
search string.
</p>
<p>To search for non-<abbr class="acronym">ASCII</abbr> characters, use one of the
following methods during incremental search:
</p>
<ul class="itemize mark-bullet">
<li><a class="index-entry-id" id="index-isearch_002dquote_002dchar"></a>
<a class="index-entry-id" id="index-C_002dq-_0028Incremental-Search_0029"></a>
Type <kbd class="kbd">C-q</kbd> (<code class="code">isearch-quote-char</code>), followed by a non-graphic
character or a sequence of octal digits.  This adds a character to the
search string, similar to inserting into a buffer using <kbd class="kbd">C-q</kbd>
(see <a class="pxref" href="Basic.xhtml#Inserting-Text">Inserting Text</a>).  For example, <kbd class="kbd">C-q C-s</kbd> during
incremental search adds the &#8216;<samp class="samp">control-S</samp>&#8217; character to the search
string.

</li><li><a class="index-entry-id" id="index-C_002d_005e-_0028Incremental-Search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dtoggle_002dinput_002dmethod"></a>
<a class="index-entry-id" id="index-isearch_002dtoggle_002dspecified_002dinput_002dmethod"></a>
<a class="index-entry-id" id="index-isearch_002dtransient_002dinput_002dmethod"></a>
Use an input method (see <a class="pxref" href="International.xhtml#Input-Methods">Input Methods</a>).  If an input method is
enabled in the current buffer when you start the search, the same
method will be active in the minibuffer when you type the search
string.  While typing the search string, you can toggle the input
method with <kbd class="kbd">C-\</kbd> (<code class="code">isearch-toggle-input-method</code>).  You can
also turn on a non-default input method with <kbd class="kbd">C-^</kbd>
(<code class="code">isearch-toggle-specified-input-method</code>), which prompts for the
name of the input method.  When an input method is active during
incremental search, the search prompt includes the input method
mnemonic, like this:

<div class="example">
<pre class="example-preformatted">I-search [<var class="var">im</var>]:
</pre></div>

<p>where <var class="var">im</var> is the mnemonic of the active input method.  Any input
method you enable during incremental search remains enabled in the
current buffer afterwards.  Finally, you can temporarily enable a
transient input method (see <a class="pxref" href="International.xhtml#transient-input-method">transient input method</a>) with
<kbd class="kbd">C-x \</kbd> (<code class="code">isearch-transient-input-method</code>) to insert a single
character to the search string using an input method, and
automatically disable the input method afterwards.
</p>
</li><li><a class="index-entry-id" id="index-isearch_002dchar_002dby_002dname"></a>
<a class="index-entry-id" id="index-C_002dx-8-RET-_0028Incremental-Search_0029"></a>
Type <kbd class="kbd">C-x 8 <kbd class="key">RET</kbd></kbd> (<code class="code">isearch-char-by-name</code>), followed by
a Unicode name or code-point in hex.  This adds the specified
character into the search string, similar to the usual
<code class="code">insert-char</code> command (see <a class="pxref" href="Basic.xhtml#Inserting-Text">Inserting Text</a>).
</li></ul>

<a class="index-entry-id" id="index-isearch_002demoji_002dby_002dname"></a>
<a class="index-entry-id" id="index-C_002dx-8-e-RET-_0028Incremental-Search_0029"></a>
<p>You can also include Emoji sequences in the search string.  Type
<kbd class="kbd">C-x&#160;8&#160;e&#160;<kbd class="key">RET</kbd></kbd><!-- /@w --> (<code class="code">isearch-emoji-by-name</code>), followed
by the Unicode name of an Emoji (for example, <kbd class="kbd">smiling face</kbd> or
<kbd class="kbd">heart with arrow</kbd>).  This adds the specified Emoji to the search
string.  If you don&#8217;t know the name of the Emoji you want to search
for, you can use <kbd class="kbd">C-x 8 e l</kbd> (<code class="code">emoji-list</code>) and <kbd class="kbd">C-x 8 e
d</kbd> (<code class="code">emoji-describe</code>) (see <a class="pxref" href="International.xhtml#Input-Methods">Input Methods</a>).
</p>
<a class="index-entry-id" id="index-M_002ds-o-_0028Incremental-Search_0029"></a>
<a class="index-entry-id" id="index-isearch_002doccur"></a>
<p>Typing <kbd class="kbd">M-s o</kbd> in incremental search invokes
<code class="code">isearch-occur</code>, which runs <code class="code">occur</code> with the current search
string.  See <a class="xref" href="#Other-Repeating-Search">occur</a>.
</p>
<a class="index-entry-id" id="index-isearch_002dquery_002dreplace"></a>
<a class="index-entry-id" id="index-isearch_002dquery_002dreplace_002dregexp"></a>
<a class="index-entry-id" id="index-M_002d_0025-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-C_002dM_002d_0025-_0028Incremental-search_0029"></a>
<p>Typing <kbd class="kbd">M-%</kbd> (<code class="code">isearch-query-replace</code>) in incremental
search invokes <code class="code">query-replace</code> or <code class="code">query-replace-regexp</code>
(depending on search mode) with the current search string used as the
string to replace.  A negative prefix argument means to replace
backward.  See <a class="xref" href="#Query-Replace">Query Replace</a>.  Typing <kbd class="kbd">C-M-%</kbd>
(<code class="code">isearch-query-replace-regexp</code>) invokes
<code class="code">query-replace-regexp</code> with the current search string used as the
regexp to replace.
</p>
<a class="index-entry-id" id="index-isearch_002dcomplete"></a>
<a class="index-entry-id" id="index-M_002dTAB-_0028Incremental-search_0029"></a>
<p>Typing <kbd class="kbd">M-<kbd class="key">TAB</kbd></kbd> in incremental search invokes
<code class="code">isearch-complete</code>, which attempts to complete the search string
using the search ring (the previous search strings you used) as a list
of completion alternatives.  See <a class="xref" href="Minibuffer.xhtml#Completion">Completion</a>.  In many operating
systems, the <kbd class="kbd">M-<kbd class="key">TAB</kbd></kbd> key sequence is captured by the window
manager; you then need to rebind <code class="code">isearch-complete</code> to another
key sequence if you want to use it (see <a class="pxref" href="Customization.xhtml#Rebinding">Changing Key Bindings Interactively</a>).
</p>
<a class="index-entry-id" id="index-M_002ds-h-r-_0028Incremental-Search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dhighlight_002dregexp"></a>
<a class="index-entry-id" id="index-M_002ds-h-l-_0028Incremental-Search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dhighlight_002dlines_002dmatching_002dregexp"></a>
<p>You can exit the search while leaving the matches highlighted by
typing <kbd class="kbd">M-s h r</kbd> (<code class="code">isearch-highlight-regexp</code>).  This runs
<code class="code">highlight-regexp</code> (see <a class="pxref" href="Display.xhtml#Highlight-Interactively">Interactive Highlighting</a>), passing it
the regexp derived from the search string and prompting you for the face
to use for highlighting.  To highlight <em class="emph">whole lines</em> containing
matches (rather than <em class="emph">just</em> the matches), type <kbd class="kbd">M-s h l</kbd>
(<code class="code">isearch-highlight-lines-matching-regexp</code>).  In either case, to
remove the highlighting, type <kbd class="kbd">M-s h u</kbd> (<code class="code">unhighlight-regexp</code>).
</p>
<a class="index-entry-id" id="index-incremental-search_002c-help-on-special-keys"></a>
<a class="index-entry-id" id="index-C_002dh-C_002dh-_0028Incremental-Search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dhelp_002dmap"></a>
<a class="index-entry-id" id="index-isearch_002dmode_002dmap"></a>
<p>When incremental search is active, you can type <kbd class="kbd">C-h C-h</kbd>
(<code class="code">isearch-help-map</code>) to access interactive help options,
including a list of special key bindings.  These key bindings are part
of the keymap <code class="code">isearch-mode-map</code> (see <a class="pxref" href="Customization.xhtml#Keymaps">Keymaps</a>).
</p>
<a class="index-entry-id" id="index-incremental-search_002c-go-to-first-or-last-occurrence"></a>
<a class="index-entry-id" id="index-M_002ds-M_002d_003e"></a>
<a class="index-entry-id" id="index-M_002ds-M_002d_003c"></a>
<p>When incremental search is active, typing <kbd class="kbd">M-s M-&gt;</kbd> will go to
the last occurrence of the search string, and <kbd class="kbd">M-s M-&lt;</kbd> will go to
the first occurrence.  With a prefix numeric argument of <var class="var">n</var>,
these commands will go to the <var class="var">n</var>th occurrence of the search
string counting from the beginning or end of the buffer,
respectively.
</p>
</div>
<div class="subsection-level-extent" id="Not-Exiting-Isearch">
<h4 class="subsection" id="Not-Exiting-Incremental-Search">16.1.6 Not Exiting Incremental Search</h4>

<p>This subsection describes how to control whether typing a command not
specifically meaningful in searches exits the search before executing
the command.  It also describes three categories of commands which you
can type without exiting the current incremental search, even though
they are not themselves part of incremental search.
</p>
<a class="index-entry-id" id="index-search_002dexit_002doption"></a>
<p>Normally, typing a command that is not bound by the incremental
search exits the search before executing the command.  Thus, the
command operates on the buffer from which you invoked the search.
However, if you customize the variable <code class="code">search-exit-option</code> to
<code class="code">append</code>, the characters which you type that are not interpreted by
the incremental search are simply appended to the search string.  This
is so you could include in the search string control characters, such
as <kbd class="kbd">C-a</kbd>, that would normally exit the search and invoke the
command bound to them on the buffer.
</p>
<dl class="table">
<dt><a class="index-entry-id" id="index-isearch_002dallow_002dprefix"></a>
<a id="index-prefix-argument-commands_002c-during-incremental-search"></a>Prefix Arguments</dt>
<dd><p>In incremental search, when you type a command that specifies a
prefix argument (see <a class="pxref" href="Basic.xhtml#Arguments">Numeric Arguments</a>), by default it will apply either
to the next action in the search or to the command that exits the
search.  In other words, entering a prefix argument will not by itself
terminate the search.
</p>
<p>In previous versions of Emacs, entering a prefix argument always
terminated the search.  You can revert to this behavior by setting the
variable <code class="code">isearch-allow-prefix</code> to <code class="code">nil</code>.
</p>
<p>When <code class="code">isearch-allow-scroll</code> is non-<code class="code">nil</code> (see below),
prefix arguments always have the default behavior described above,
i.e., they don&#8217;t terminate the search, even if
<code class="code">isearch-allow-prefix</code> is <code class="code">nil</code>.
</p>
</dd>
<dt><a class="index-entry-id" id="index-isearch_002dallow_002dscroll"></a>
<a class="index-entry-id" id="index-scroll_002dcommand-property_002c-and-incremental-search"></a>
<a id="index-scrolling-commands_002c-during-incremental-search"></a>Scrolling Commands</dt>
<dd><p>Normally, scrolling commands exit incremental search.  But if you
change the variable <code class="code">isearch-allow-scroll</code> to a non-<code class="code">nil</code>
value, that enables the use of the scroll-bar, as well as keyboard
scrolling commands like <kbd class="kbd">C-v</kbd>, <kbd class="kbd">M-v</kbd>, and <kbd class="kbd">C-l</kbd>
(see <a class="pxref" href="Display.xhtml#Scrolling">Scrolling</a>), which have a non-<code class="code">nil</code> <code class="code">scroll-command</code>
property, without exiting the search.  This applies only to calling
these commands via their bound key sequences&#8212;typing <kbd class="kbd">M-x</kbd> will
still exit the search.  You can give prefix arguments to these
commands in the usual way.  This feature normally won&#8217;t let you scroll
the current match out of visibility; but if you customize
<code class="code">isearch-allow-scroll</code> to the special value <code class="code">unlimited</code>,
that restriction is lifted.
</p>
<a class="index-entry-id" id="index-isearch_002dscroll-property"></a>
<a class="index-entry-id" id="index-prevent-commands-from-exiting-incremental-search"></a>
<p>The <code class="code">isearch-allow-scroll</code> feature also affects some other
commands, such as <kbd class="kbd">C-x 2</kbd> (<code class="code">split-window-below</code>) and
<kbd class="kbd">C-x ^</kbd> (<code class="code">enlarge-window</code>), which don&#8217;t exactly scroll but do
affect where the text appears on the screen.  In fact, it affects
any command that has a non-<code class="code">nil</code> <code class="code">isearch-scroll</code> property.
So you can control which commands are affected by changing these
properties.
</p>
<p>For example, to make <kbd class="kbd">C-h l</kbd> usable within an incremental search
in all future Emacs sessions, use <kbd class="kbd">C-h c</kbd> to find what command it
runs (see <a class="pxref" href="Help.xhtml#Key-Help">Documentation for a Key</a>), which is <code class="code">view-lossage</code>.  Then you can
put the following line in your init file (see <a class="pxref" href="Customization.xhtml#Init-File">The Emacs Initialization File</a>):
</p>
<div class="example">
<pre class="example-preformatted">(put 'view-lossage 'isearch-scroll t)
</pre></div>

<p>This feature can be applied to any command that doesn&#8217;t permanently
change point, the buffer contents, the match data, the current buffer,
or the selected window and frame.  The command must not itself attempt
an incremental search.  This feature is disabled if
<code class="code">isearch-allow-scroll</code> is <code class="code">nil</code> (which it is by default).
</p>
<a class="index-entry-id" id="index-isearch_002dallow_002dmotion"></a>
<a class="index-entry-id" id="index-isearch_002dmotion_002dchanges_002ddirection"></a>
<p>Likewise, if you change the variable <code class="code">isearch-allow-motion</code>
to a non-<code class="code">nil</code> value, this enables the use of the keyboard motion
commands <kbd class="kbd">M-&lt;</kbd>, <kbd class="kbd">M-&gt;</kbd>, <kbd class="kbd">C-v</kbd> and <kbd class="kbd">M-v</kbd>, to move
respectively to the first occurrence of the current search string in
the buffer, the last one, the first one after the current window,
and the last one before the current window.  The search direction
does not change when these motion commands are used, unless you change
the variable <code class="code">isearch-motion-changes-direction</code> to a non-<code class="code">nil</code>
value, in which case the search direction is forward after <kbd class="kbd">M-&lt;</kbd> and
<kbd class="kbd">C-v</kbd>, and backward after <kbd class="kbd">M-&gt;</kbd> and <kbd class="kbd">M-v</kbd>.
</p>
</dd>
<dt><a id="index-motion-commands_002c-during-incremental-search"></a>Motion Commands</dt>
<dd><p>When <code class="code">isearch-yank-on-move</code> is customized to <code class="code">shift</code>,
you can extend the search string by holding down the shift key while
typing cursor motion commands.  It will yank text that ends at the new
position after moving point in the current buffer.
</p>
<a class="index-entry-id" id="index-isearch_002dmove-property"></a>
<p>When <code class="code">isearch-yank-on-move</code> is <code class="code">t</code>, you can extend the
search string without using the shift key for cursor motion commands,
but it applies only for certain motion command that have the
<code class="code">isearch-move</code> property on their symbols.
</p></dd>
</dl>

</div>
<div class="subsection-level-extent" id="Isearch-Minibuffer">
<h4 class="subsection" id="Searching-the-Minibuffer">16.1.7 Searching the Minibuffer</h4>
<a class="index-entry-id" id="index-minibuffer-history_002c-searching"></a>

<p>If you start an incremental search while the minibuffer is active,
Emacs searches the contents of the minibuffer.  Unlike searching an
ordinary buffer, the search string is not shown in the echo area,
because that is used to display the minibuffer.
</p>
<p>If an incremental search fails in the minibuffer, it tries searching
the minibuffer history.  See <a class="xref" href="Minibuffer.xhtml#Minibuffer-History">Minibuffer History</a>.  You can visualize
the minibuffer and its history as a series of pages, with the
earliest history element on the first page and the current minibuffer
on the last page.  A forward search, <kbd class="kbd">C-s</kbd>, searches forward to
later pages; a reverse search, <kbd class="kbd">C-r</kbd>, searches backwards to
earlier pages.  Like in ordinary buffer search, a failing search can
wrap around, going from the last page to the first page or vice versa.
</p>
<p>When the current match is on a history element, that history element
is pulled into the minibuffer.  If you exit the incremental search
normally (e.g., by typing <kbd class="key">RET</kbd>), it remains in the minibuffer
afterwards.  Canceling the search, with <kbd class="kbd">C-g</kbd>, restores the
contents of the minibuffer when you began the search.
</p>
</div>
</div>
<div class="section-level-extent" id="Nonincremental-Search">
<h3 class="section" id="Nonincremental-Search-1">16.2 Nonincremental Search</h3>
<a class="index-entry-id" id="index-nonincremental-search"></a>

<p>Emacs also has conventional nonincremental search commands, which require
you to type the entire search string before searching begins.
</p>
<dl class="table">
<dt><kbd class="kbd">C-s <kbd class="key">RET</kbd> <var class="var">string</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Search for <var class="var">string</var>.
</p></dd>
<dt><kbd class="kbd">C-r <kbd class="key">RET</kbd> <var class="var">string</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Search backward for <var class="var">string</var>.
</p></dd>
</dl>

<p>To start a nonincremental search, first type <kbd class="kbd">C-s <kbd class="key">RET</kbd></kbd>.
This enters the minibuffer to read the search string; terminate the
string with <kbd class="key">RET</kbd>, and then the search takes place.  If the string
is not found, the search command signals an error.
</p>
<p>When you type <kbd class="kbd">C-s <kbd class="key">RET</kbd></kbd>, the <kbd class="kbd">C-s</kbd> invokes incremental
search as usual.  That command is specially programmed to invoke the
command for nonincremental search, if the string you specify is empty.
(Such an empty argument would otherwise be useless.)  <kbd class="kbd">C-r
<kbd class="key">RET</kbd></kbd> does likewise, invoking the nonincremental
backward-searching command.
</p>
<p>Nonincremental search can also be invoked from the menu bar&#8217;s
&#8216;<samp class="samp">Edit-&gt;Search</samp>&#8217; menu.
</p>
<a class="index-entry-id" id="index-search_002dforward"></a>
<a class="index-entry-id" id="index-search_002dbackward"></a>
<p>You can also use two simpler commands, <kbd class="kbd">M-x search-forward</kbd> and
<kbd class="kbd">M-x search-backward</kbd>.  These commands look for the literal
strings you specify, and don&#8217;t support any of the lax-search features
(see <a class="pxref" href="#Lax-Search">Lax Matching During Searching</a>) except case folding.
</p>
</div>
<div class="section-level-extent" id="Word-Search">
<h3 class="section" id="Word-Search-1">16.3 Word Search</h3>
<a class="index-entry-id" id="index-word-search"></a>

<p>A <em class="dfn">word search</em> finds a sequence of words without regard to the
type of punctuation between them.  For instance, if you enter a search
string that consists of two words separated by a single space, the
search matches any sequence of those two words separated by one or
more spaces, newlines, or other punctuation characters.  This is
particularly useful for searching text documents, because you don&#8217;t
have to worry whether the words you are looking for are separated by
newlines or spaces.  Note that major modes for programming languages
or other specialized modes can modify the definition of a word to suit
their syntactic needs.
</p>
<dl class="table">
<dt><kbd class="kbd">M-s w</kbd></dt>
<dd><p>If incremental search is active, toggle word search mode
(<code class="code">isearch-toggle-word</code>); otherwise, begin an incremental forward
word search (<code class="code">isearch-forward-word</code>).
</p></dd>
<dt><kbd class="kbd">M-s w <kbd class="key">RET</kbd> <var class="var">words</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Search for <var class="var">words</var>, using a forward nonincremental word search.
</p></dd>
<dt><kbd class="kbd">M-s w C-r <kbd class="key">RET</kbd> <var class="var">words</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Search backward for <var class="var">words</var>, using a nonincremental word search.
</p></dd>
<dt><kbd class="kbd">M-s M-w</kbd></dt>
<dd><p>Search the Web for the text in region.
</p></dd>
</dl>

<a class="index-entry-id" id="index-isearch_002dforward_002dword"></a>
<a class="index-entry-id" id="index-isearch_002dtoggle_002dword"></a>
<a class="index-entry-id" id="index-M_002ds-w"></a>
<p>To begin a forward incremental word search, type <kbd class="kbd">M-s w</kbd>.  If
incremental search is not already active, this runs the command
<code class="code">isearch-forward-word</code>.  If incremental search is already active
(whether a forward or backward search), <kbd class="kbd">M-s w</kbd> runs the command
<code class="code">isearch-toggle-word</code>, which switches to a word search while
keeping the direction of the search and the current search string
unchanged.  You can toggle word search back off by typing <kbd class="kbd">M-s w</kbd>
again.
</p>
<a class="index-entry-id" id="index-word_002dsearch_002dforward"></a>
<a class="index-entry-id" id="index-word_002dsearch_002dbackward"></a>
<p>To begin a nonincremental word search, type <kbd class="kbd">M-s w <kbd class="key">RET</kbd></kbd>
for a forward search, or <kbd class="kbd">M-s w C-r <kbd class="key">RET</kbd></kbd> for a backward search.
These run the commands <code class="code">word-search-forward</code> and
<code class="code">word-search-backward</code> respectively.
</p>
<p>Incremental and nonincremental word searches differ slightly in the
way they find a match.  In a nonincremental word search, each word in
the search string must exactly match a whole word.  In an incremental
word search, the matching is more lax: while you are typing the search
string, its first and last words need not match whole words.  This is
so that the matching can proceed incrementally as you type.  This
additional laxity does not apply to the lazy highlight
(see <a class="pxref" href="#Incremental-Search">Incremental Search</a>), which always matches whole words.
While you are typing the search string, &#8216;<samp class="samp">Pending</samp>&#8217; appears in the
search prompt until you use a search repeating key like <kbd class="kbd">C-s</kbd>.
</p>
<p>The word search commands don&#8217;t perform character folding, and
toggling lax whitespace matching (see <a class="pxref" href="#Lax-Search">lax space
matching</a>) has no effect on them.
</p>
<a class="index-entry-id" id="index-M_002ds-M_002dw"></a>
<a class="index-entry-id" id="index-eww_002dsearch_002dwords"></a>
<a class="index-entry-id" id="index-eww_002dsearch_002dprefix"></a>
<a class="index-entry-id" id="index-Internet-search"></a>
<a class="index-entry-id" id="index-search-Internet-for-keywords"></a>
<p>To search the Web for the text in region, type <kbd class="kbd">M-s M-w</kbd>.  This
command performs an Internet search for the words in region using the
search engine whose <abbr class="acronym">URL</abbr> is specified by the variable
<code class="code">eww-search-prefix</code> (see <a href="https://www.gnu.org/software/emacs/manual/html_node/eww/Basics.html#Basics">EWW</a> in <cite class="cite">The Emacs Web
Wowser Manual</cite>).  If the region is not active, or doesn&#8217;t contain any
words, this command prompts the user for a URL or keywords to search.
</p>

</div>
<div class="section-level-extent" id="Symbol-Search">
<h3 class="section" id="Symbol-Search-1">16.4 Symbol Search</h3>
<a class="index-entry-id" id="index-symbol-search"></a>

<p>A <em class="dfn">symbol search</em> is much like an ordinary search, except that
the boundaries of the search must match the boundaries of a symbol.
The meaning of <em class="dfn">symbol</em> in this context depends on the major mode,
and usually refers to a source code token, such as a Lisp symbol in
Emacs Lisp mode.  For instance, if you perform an incremental symbol
search for the Lisp symbol <code class="code">forward-word</code>, it would not match
<code class="code">isearch-forward-word</code>.  This feature is thus mainly useful for
searching source code.
</p>
<dl class="table">
<dt><a id="index-isearch_002dtoggle_002dsymbol"></a><kbd class="kbd">M-s _</kbd></dt>
<dd><p>If incremental search is active, toggle symbol search mode
(<code class="code">isearch-toggle-symbol</code>); otherwise, begin an incremental
forward symbol search (<code class="code">isearch-forward-symbol</code>).
</p></dd>
<dt><kbd class="kbd">M-s .</kbd></dt>
<dd><p>Start a symbol incremental search forward with the symbol found near
point added to the search string initially.
</p></dd>
<dt><kbd class="kbd">M-s _ <kbd class="key">RET</kbd> <var class="var">symbol</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Search forward for <var class="var">symbol</var>, nonincrementally.
</p></dd>
<dt><kbd class="kbd">M-s _ C-r <kbd class="key">RET</kbd> <var class="var">symbol</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Search backward for <var class="var">symbol</var>, nonincrementally.
</p></dd>
</dl>

<a class="index-entry-id" id="index-M_002ds-_005f"></a>
<a class="index-entry-id" id="index-M_002ds-_002e"></a>
<a class="index-entry-id" id="index-isearch_002dforward_002dsymbol"></a>
<a class="index-entry-id" id="index-isearch_002dforward_002dsymbol_002dat_002dpoint"></a>
<p>To begin a forward incremental symbol search, type <kbd class="kbd">M-s _</kbd> (or
<kbd class="kbd">M-s .</kbd> if the symbol to search is near point).  If incremental
search is not already active, <kbd class="kbd">M-s _</kbd> runs the command
<code class="code">isearch-forward-symbol</code> and <kbd class="kbd">M-s .</kbd> runs the command
<code class="code">isearch-forward-symbol-at-point</code>.  With a numeric prefix
argument of <var class="var">n</var>, <kbd class="kbd">M-s .</kbd> will search for the <var class="var">n</var>the next
occurrence of the symbol at point; negative values of <var class="var">n</var> search
backwards.  If incremental search is already active, <kbd class="kbd">M-s _</kbd>
switches to a symbol search, preserving the direction of the search
and the current search string; you can disable symbol search by typing
<kbd class="kbd">M-s _</kbd> again.  In incremental symbol search, while you are typing
the search string, only the beginning of the search string is required
to match the beginning of a symbol, and &#8216;<samp class="samp">Pending</samp>&#8217; appears in the
search prompt until you use a search repeating key like <kbd class="kbd">C-s</kbd>.
</p>
<p>To begin a nonincremental symbol search, type <kbd class="kbd">M-s _ <kbd class="key">RET</kbd></kbd>
for a forward search, or <kbd class="kbd">M-s _ C-r <kbd class="key">RET</kbd></kbd> or a backward
search.  In nonincremental symbol searches, the beginning and end of
the search string are required to match the beginning and end of a
symbol, respectively.
</p>
<p>The symbol search commands don&#8217;t perform character folding, and
toggling lax whitespace matching (see <a class="pxref" href="#Lax-Search">lax space
matching</a>) has no effect on them.
</p>
</div>
<div class="section-level-extent" id="Regexp-Search">
<h3 class="section" id="Regular-Expression-Search">16.5 Regular Expression Search</h3>
<a class="index-entry-id" id="index-regexp-search"></a>
<a class="index-entry-id" id="index-search-for-a-regular-expression"></a>

<p>A <em class="dfn">regular expression</em> (or <em class="dfn">regexp</em> for short) is a pattern
that denotes a class of alternative strings to match.  Emacs
provides both incremental and nonincremental ways to search for a
match for a regexp.  The syntax of regular expressions is explained in
the next section.
</p>
<dl class="table">
<dt><kbd class="kbd">C-M-s</kbd></dt>
<dd><p>Begin incremental regexp search (<code class="code">isearch-forward-regexp</code>).
</p></dd>
<dt><kbd class="kbd">C-M-r</kbd></dt>
<dd><p>Begin reverse incremental regexp search (<code class="code">isearch-backward-regexp</code>).
</p></dd>
</dl>

<a class="index-entry-id" id="index-C_002dM_002ds"></a>
<a class="index-entry-id" id="index-isearch_002dforward_002dregexp"></a>
<a class="index-entry-id" id="index-C_002dM_002dr"></a>
<a class="index-entry-id" id="index-isearch_002dbackward_002dregexp"></a>
<p>Incremental search for a regexp is done by typing <kbd class="kbd">C-M-s</kbd>
(<code class="code">isearch-forward-regexp</code>), by invoking <kbd class="kbd">C-s</kbd> with a
prefix argument (whose value does not matter), or by typing <kbd class="kbd">M-r</kbd>
within a forward incremental search.  This command reads a
search string incrementally just like <kbd class="kbd">C-s</kbd>, but it treats the
search string as a regexp rather than looking for an exact match
against the text in the buffer.  Each time you add text to the search
string, you make the regexp longer, and the new regexp is searched
for.  To search backward for a regexp, use <kbd class="kbd">C-M-r</kbd>
(<code class="code">isearch-backward-regexp</code>), <kbd class="kbd">C-r</kbd> with a prefix argument,
or <kbd class="kbd">M-r</kbd> within a backward incremental search.
</p>
<a class="index-entry-id" id="index-regexp_002dsearch_002dring_002dmax"></a>
<p>All of the special key sequences in an ordinary incremental search
(see <a class="pxref" href="#Special-Isearch">Special Input for Incremental Search</a>) do similar things in an incremental regexp
search.  For instance, typing <kbd class="kbd">C-s</kbd> immediately after starting the
search retrieves the last incremental search regexp used and searches
forward for it.  Incremental regexp and non-regexp searches have
independent defaults.  They also have separate search rings, which you
can access with <kbd class="kbd">M-p</kbd> and <kbd class="kbd">M-n</kbd>.  The maximum number of search
regexps saved in the search ring is determined by the value of
<code class="code">regexp-search-ring-max</code>, 16 by default.
</p>
<p>Unlike ordinary incremental search, incremental regexp search
does not use lax space matching by default.  To toggle this feature
use <kbd class="kbd">M-s <kbd class="key">SPC</kbd></kbd> (<code class="code">isearch-toggle-lax-whitespace</code>).
Then any <kbd class="key">SPC</kbd> typed in incremental regexp search will match
any sequence of one or more whitespace characters.  The variable
<code class="code">search-whitespace-regexp</code> specifies the regexp for the lax
space matching.  See <a class="xref" href="#Special-Isearch">Special Input for Incremental Search</a>.
</p>
<p>Also unlike ordinary incremental search, incremental regexp search
cannot use character folding (see <a class="pxref" href="#Lax-Search">Lax Matching During Searching</a>).  (If you toggle
character folding during incremental regexp search with <kbd class="kbd">M-s '</kbd>,
the search becomes a non-regexp search and the search pattern you
typed is interpreted as a literal string.)
</p>
<a class="index-entry-id" id="index-pending_002c-in-incremental-search"></a>
<p>In some cases, adding characters to the regexp in an incremental
regexp search can make the cursor move back and start again.  For
example, if you have searched for &#8216;<samp class="samp">foo</samp>&#8217; and you add &#8216;<samp class="samp">\|bar</samp>&#8217;,
the cursor backs up in case the first &#8216;<samp class="samp">bar</samp>&#8217; precedes the first
&#8216;<samp class="samp">foo</samp>&#8217;.  (The prompt will change to say &#8220;Pending&#8221; to notify the
user that this recalculation has happened.)   See <a class="xref" href="#Regexps">Syntax of Regular Expressions</a>.
</p>
<p>Forward and backward regexp search are not symmetrical, because
regexp matching in Emacs always operates forward, starting with the
beginning of the regexp.  Thus, forward regexp search scans forward,
trying a forward match at each possible starting position.  Backward
regexp search scans backward, trying a forward match at each possible
starting position.  These search methods are not mirror images.
</p>
<a class="index-entry-id" id="index-re_002dsearch_002dforward"></a>
<a class="index-entry-id" id="index-re_002dsearch_002dbackward"></a>
<p>Nonincremental search for a regexp is done with the commands
<code class="code">re-search-forward</code> and <code class="code">re-search-backward</code>.  You can
invoke these with <kbd class="kbd">M-x</kbd>, or by way of incremental regexp search
with <kbd class="kbd">C-M-s <kbd class="key">RET</kbd></kbd> and <kbd class="kbd">C-M-r <kbd class="key">RET</kbd></kbd>.  When you invoke
these commands with <kbd class="kbd">M-x</kbd>, they search for the exact regexp you
specify, and thus don&#8217;t support any lax-search features (see <a class="pxref" href="#Lax-Search">Lax Matching During Searching</a>) except case folding.
</p>
<p>If you use the incremental regexp search commands with a prefix
argument, they perform ordinary string search, like
<code class="code">isearch-forward</code> and <code class="code">isearch-backward</code>.  See <a class="xref" href="#Incremental-Search">Incremental Search</a>.
</p>
</div>
<div class="section-level-extent" id="Regexps">
<h3 class="section" id="Syntax-of-Regular-Expressions">16.6 Syntax of Regular Expressions</h3>
<a class="index-entry-id" id="index-syntax-of-regexps"></a>
<a class="index-entry-id" id="index-regular-expression"></a>
<a class="index-entry-id" id="index-regexp"></a>

<p>This section (and this manual in general) describes regular
expression features that users typically use.  See <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Regular-Expressions.html#Regular-Expressions">Regular
Expressions</a> in <cite class="cite">The Emacs Lisp Reference Manual</cite>, for additional
features used mainly in Lisp programs.
</p>
<p>Regular expressions have a syntax in which a few characters are
<em class="dfn">special constructs</em> and the rest are <em class="dfn">ordinary</em>.  An ordinary
character matches that same character and nothing else.  The special
characters are &#8216;<samp class="samp">$^.*+?[\</samp>&#8217;.  The character &#8216;<samp class="samp">]</samp>&#8217; is special if
it ends a character alternative (see below).  The character &#8216;<samp class="samp">-</samp>&#8217;
is special inside a character alternative.  Any other character
appearing in a regular expression is ordinary, unless a &#8216;<samp class="samp">\</samp>&#8217;
precedes it.  (When you use regular expressions in a Lisp program,
each &#8216;<samp class="samp">\</samp>&#8217; must be doubled, see the example near the end of this
section.)
</p>
<p>For example, &#8216;<samp class="samp">f</samp>&#8217; is not a special character, so it is ordinary, and
therefore &#8216;<samp class="samp">f</samp>&#8217; is a regular expression that matches the string
&#8216;<samp class="samp">f</samp>&#8217; and no other string.  (It does <em class="emph">not</em> match the string
&#8216;<samp class="samp">ff</samp>&#8217;.)  Likewise, &#8216;<samp class="samp">o</samp>&#8217; is a regular expression that matches
only &#8216;<samp class="samp">o</samp>&#8217;.  (When case distinctions are being ignored, these regexps
also match &#8216;<samp class="samp">F</samp>&#8217; and &#8216;<samp class="samp">O</samp>&#8217;, but we consider this a generalization
of &#8220;the same string&#8221;, rather than an exception.)
</p>
<p>Any two regular expressions <var class="var">a</var> and <var class="var">b</var> can be concatenated.
The result is a regular expression which matches a string if <var class="var">a</var>
matches some amount of the beginning of that string and <var class="var">b</var>
matches the rest of the string.  As a trivial example, concatenating
the regular expressions &#8216;<samp class="samp">f</samp>&#8217; and &#8216;<samp class="samp">o</samp>&#8217; gives the regular
expression &#8216;<samp class="samp">fo</samp>&#8217;, which matches only the string &#8216;<samp class="samp">fo</samp>&#8217;.  To do
something less trivial, you need to use one of the special characters.
Here is a list of them.
</p>
<dl class="table">
<dt><kbd class="kbd">.</kbd> <span class="r">(Period)</span></dt>
<dd><p>is a special character that matches any single character except a
newline.  For example, the regular expressions &#8216;<samp class="samp">a.b</samp>&#8217; matches any
three-character string that begins with &#8216;<samp class="samp">a</samp>&#8217; and ends with
&#8216;<samp class="samp">b</samp>&#8217;.
</p>
</dd>
<dt><kbd class="kbd">*</kbd></dt>
<dd><p>is not a construct by itself; it is a postfix operator that means to
match the preceding regular expression repetitively any number of
times, as many times as possible.  Thus, &#8216;<samp class="samp">o*</samp>&#8217; matches any number
of &#8216;<samp class="samp">o</samp>&#8217;s, including no &#8216;<samp class="samp">o</samp>&#8217;s.
</p>
<p>&#8216;<samp class="samp">*</samp>&#8217; always applies to the <em class="emph">smallest</em> possible preceding
expression.  Thus, &#8216;<samp class="samp">fo*</samp>&#8217; has a repeating &#8216;<samp class="samp">o</samp>&#8217;, not a repeating
&#8216;<samp class="samp">fo</samp>&#8217;.  It matches &#8216;<samp class="samp">f</samp>&#8217;, &#8216;<samp class="samp">fo</samp>&#8217;, &#8216;<samp class="samp">foo</samp>&#8217;, and so on.
</p>
<p>The matcher processes a &#8216;<samp class="samp">*</samp>&#8217; construct by matching, immediately,
as many repetitions as can be found.  Then it continues with the rest
of the pattern.  If that fails, backtracking occurs, discarding some
of the matches of the &#8216;<samp class="samp">*</samp>&#8217;-modified construct in case that makes
it possible to match the rest of the pattern.  For example, in matching
&#8216;<samp class="samp">ca*ar</samp>&#8217; against the string &#8216;<samp class="samp">caaar</samp>&#8217;, the &#8216;<samp class="samp">a*</samp>&#8217; first
tries to match all three &#8216;<samp class="samp">a</samp>&#8217;s; but the rest of the pattern is
&#8216;<samp class="samp">ar</samp>&#8217; and there is only &#8216;<samp class="samp">r</samp>&#8217; left to match, so this try fails.
The next alternative is for &#8216;<samp class="samp">a*</samp>&#8217; to match only two &#8216;<samp class="samp">a</samp>&#8217;s.
With this choice, the rest of the regexp matches successfully.
</p>
</dd>
<dt><kbd class="kbd">+</kbd></dt>
<dd><p>is a postfix operator, similar to &#8216;<samp class="samp">*</samp>&#8217; except that it must match
the preceding expression at least once.  Thus, &#8216;<samp class="samp">ca+r</samp>&#8217; matches the
strings &#8216;<samp class="samp">car</samp>&#8217; and &#8216;<samp class="samp">caaaar</samp>&#8217; but not the string &#8216;<samp class="samp">cr</samp>&#8217;,
whereas &#8216;<samp class="samp">ca*r</samp>&#8217; matches all three strings.
</p>
</dd>
<dt><kbd class="kbd">?</kbd></dt>
<dd><p>is a postfix operator, similar to &#8216;<samp class="samp">*</samp>&#8217; except that it can match
the preceding expression either once or not at all.  Thus, &#8216;<samp class="samp">ca?r</samp>&#8217;
matches &#8216;<samp class="samp">car</samp>&#8217; or &#8216;<samp class="samp">cr</samp>&#8217;, and nothing else.
</p>
</dd>
<dt><a id="index-non_002dgreedy-regexp-matching"></a><kbd class="kbd">*?</kbd>, <kbd class="kbd">+?</kbd>, <kbd class="kbd">??</kbd></dt>
<dd><p>are non-<em class="dfn">greedy</em> variants of the operators above.  The normal
operators &#8216;<samp class="samp">*</samp>&#8217;, &#8216;<samp class="samp">+</samp>&#8217;, &#8216;<samp class="samp">?</samp>&#8217; match as much as they can, as
long as the overall regexp can still match.  With a following
&#8216;<samp class="samp">?</samp>&#8217;, they will match as little as possible.
</p>
<p>Thus, both &#8216;<samp class="samp">ab*</samp>&#8217; and &#8216;<samp class="samp">ab*?</samp>&#8217; can match the string &#8216;<samp class="samp">a</samp>&#8217;
and the string &#8216;<samp class="samp">abbbb</samp>&#8217;; but if you try to match them both against
the text &#8216;<samp class="samp">abbb</samp>&#8217;, &#8216;<samp class="samp">ab*</samp>&#8217; will match it all (the longest valid
match), while &#8216;<samp class="samp">ab*?</samp>&#8217;  will match just &#8216;<samp class="samp">a</samp>&#8217; (the shortest
valid match).
</p>
<p>Non-greedy operators match the shortest possible string starting at a
given starting point; in a forward search, though, the earliest
possible starting point for match is always the one chosen.  Thus, if
you search for &#8216;<samp class="samp">a.*?$</samp>&#8217; against the text &#8216;<samp class="samp">abbab</samp>&#8217; followed by
a newline, it matches the whole string.  Since it <em class="emph">can</em> match
starting at the first &#8216;<samp class="samp">a</samp>&#8217;, it does.
</p>
</dd>
<dt><a class="index-entry-id" id="index-character-set_002c-in-regular-expressions"></a>
<a id="index-set-of-alternative-characters_002c-in-regular-expressions"></a><kbd class="kbd">[ &#8230; ]</kbd></dt>
<dd><p>is a <em class="dfn">set of alternative characters</em>, or a <em class="dfn">character set</em>,
beginning with &#8216;<samp class="samp">[</samp>&#8217; and terminated by &#8216;<samp class="samp">]</samp>&#8217;.
</p>
<p>In the simplest case, the characters between the two brackets are what
this set can match.  Thus, &#8216;<samp class="samp">[ad]</samp>&#8217; matches either one &#8216;<samp class="samp">a</samp>&#8217; or
one &#8216;<samp class="samp">d</samp>&#8217;, and &#8216;<samp class="samp">[ad]*</samp>&#8217; matches any string composed of just
&#8216;<samp class="samp">a</samp>&#8217;s and &#8216;<samp class="samp">d</samp>&#8217;s (including the empty string).  It follows that
&#8216;<samp class="samp">c[ad]*r</samp>&#8217; matches &#8216;<samp class="samp">cr</samp>&#8217;, &#8216;<samp class="samp">car</samp>&#8217;, &#8216;<samp class="samp">cdr</samp>&#8217;,
&#8216;<samp class="samp">caddaar</samp>&#8217;, etc.
</p>
<p>You can also include character ranges in a character set, by writing the
starting and ending characters with a &#8216;<samp class="samp">-</samp>&#8217; between them.  Thus,
&#8216;<samp class="samp">[a-z]</samp>&#8217; matches any lower-case <abbr class="acronym">ASCII</abbr> letter.  Ranges may be
intermixed freely with individual characters, as in &#8216;<samp class="samp">[a-z$%.]</samp>&#8217;,
which matches any lower-case <abbr class="acronym">ASCII</abbr> letter or &#8216;<samp class="samp">$</samp>&#8217;, &#8216;<samp class="samp">%</samp>&#8217; or
period.  As another example, &#8216;<samp class="samp">[α-ωί]</samp>&#8217; matches all lower-case
Greek letters.
</p>
<a class="index-entry-id" id="index-character-classes_002c-in-regular-expressions"></a>
<p>You can also include certain special <em class="dfn">character classes</em> in a
character set.  A &#8216;<samp class="samp">[:</samp>&#8217; and balancing &#8216;<samp class="samp">:]</samp>&#8217; enclose a
character class inside a set of alternative characters.  For instance,
&#8216;<samp class="samp">[[:alnum:]]</samp>&#8217; matches any letter or digit.  See <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Char-Classes.html#Char-Classes">Char Classes</a> in <cite class="cite">The Emacs Lisp Reference Manual</cite>, for a list of character
classes.
</p>
<p>To include a &#8216;<samp class="samp">]</samp>&#8217; in a character set, you must make it the first character.
For example, &#8216;<samp class="samp">[]a]</samp>&#8217; matches &#8216;<samp class="samp">]</samp>&#8217; or &#8216;<samp class="samp">a</samp>&#8217;.  To include a &#8216;<samp class="samp">-</samp>&#8217;,
write &#8216;<samp class="samp">-</samp>&#8217; as the last character of the set, tho you can also put it first
or after a range.  Thus, &#8216;<samp class="samp">[]-]</samp>&#8217; matches both &#8216;<samp class="samp">]</samp>&#8217; and &#8216;<samp class="samp">-</samp>&#8217;.
</p>
<p>To include &#8216;<samp class="samp">^</samp>&#8217; in a set, put it anywhere but at the beginning of
the set.  (At the beginning, it complements the set&#8212;see below.)
</p>
<p>When you use a range in case-insensitive search, you should write both
ends of the range in upper case, or both in lower case, or both should
be non-letters.  The behavior of a mixed-case range such as &#8216;<samp class="samp">A-z</samp>&#8217;
is somewhat ill-defined, and it may change in future Emacs versions.
</p>
</dd>
<dt><kbd class="kbd">[^ &#8230; ]</kbd></dt>
<dd><p>&#8216;<samp class="samp">[^</samp>&#8217; begins a <em class="dfn">complemented character set</em>, which matches any
character except the ones specified.  Thus, &#8216;<samp class="samp">[^a-z0-9A-Z]</samp>&#8217; matches
all characters <em class="emph">except</em> <abbr class="acronym">ASCII</abbr> letters and digits.
</p>
<p>&#8216;<samp class="samp">^</samp>&#8217; is not special in a character set unless it is the first
character.  The character following the &#8216;<samp class="samp">^</samp>&#8217; is treated as if it
were first (in other words, &#8216;<samp class="samp">-</samp>&#8217; and &#8216;<samp class="samp">]</samp>&#8217; are not special there).
</p>
<p>A complemented character set can match a newline, unless newline is
mentioned as one of the characters not to match.  This is in contrast to
the handling of regexps in programs such as <code class="code">grep</code>.
</p>
</dd>
<dt><kbd class="kbd">^</kbd></dt>
<dd><p>is a special character that matches the empty string, but only at the
beginning of a line in the text being matched.  Otherwise it fails to
match anything.  Thus, &#8216;<samp class="samp">^foo</samp>&#8217; matches a &#8216;<samp class="samp">foo</samp>&#8217; that occurs at
the beginning of a line.
</p>
<p>For historical compatibility reasons, &#8216;<samp class="samp">^</samp>&#8217; can be used with this
meaning only at the beginning of the regular expression, or after
&#8216;<samp class="samp">\(</samp>&#8217; or &#8216;<samp class="samp">\|</samp>&#8217;.
</p>
</dd>
<dt><kbd class="kbd">$</kbd></dt>
<dd><p>is similar to &#8216;<samp class="samp">^</samp>&#8217; but matches only at the end of a line.  Thus,
&#8216;<samp class="samp">x+$</samp>&#8217; matches a string of one &#8216;<samp class="samp">x</samp>&#8217; or more at the end of a line.
</p>
<p>For historical compatibility reasons, &#8216;<samp class="samp">$</samp>&#8217; can be used with this
meaning only at the end of the regular expression, or before &#8216;<samp class="samp">\)</samp>&#8217;
or &#8216;<samp class="samp">\|</samp>&#8217;.
</p>
</dd>
<dt><kbd class="kbd">\</kbd></dt>
<dd><p>has two functions: it quotes the special characters (including
&#8216;<samp class="samp">\</samp>&#8217;), and it introduces additional special constructs.
</p>
<p>Because &#8216;<samp class="samp">\</samp>&#8217; quotes special characters, &#8216;<samp class="samp">\$</samp>&#8217; is a regular
expression that matches only &#8216;<samp class="samp">$</samp>&#8217;, and &#8216;<samp class="samp">\[</samp>&#8217; is a regular
expression that matches only &#8216;<samp class="samp">[</samp>&#8217;, and so on.
</p>
<p>See the following section for the special constructs that begin
with &#8216;<samp class="samp">\</samp>&#8217;.
</p></dd>
</dl>

<p>Note: for historical compatibility, special characters are treated as
ordinary ones if they are in contexts where their special meanings make no
sense.  For example, &#8216;<samp class="samp">*foo</samp>&#8217; treats &#8216;<samp class="samp">*</samp>&#8217; as ordinary since there is
no preceding expression on which the &#8216;<samp class="samp">*</samp>&#8217; can act.  It is poor practice
to depend on this behavior; it is better to quote the special character anyway,
regardless of where it appears.
</p>
<p>As a &#8216;<samp class="samp">\</samp>&#8217; is not special inside a set of alternative characters, it can
never remove the special meaning of &#8216;<samp class="samp">-</samp>&#8217;, &#8216;<samp class="samp">^</samp>&#8217; or &#8216;<samp class="samp">]</samp>&#8217;.
You should not quote these characters when they have no special
meaning.  This would not clarify anything, since backslashes
can legitimately precede these characters where they <em class="emph">have</em>
special meaning, as in &#8216;<samp class="samp">[^\]</samp>&#8217; (<code class="code">&quot;[^\\]&quot;</code> for Lisp string
syntax), which matches any single character except a backslash.
</p>
</div>
<div class="section-level-extent" id="Regexp-Backslash">
<h3 class="section" id="Backslash-in-Regular-Expressions">16.7 Backslash in Regular Expressions</h3>

<p>For the most part, &#8216;<samp class="samp">\</samp>&#8217; followed by any character matches only
that character.  However, there are several exceptions: two-character
sequences starting with &#8216;<samp class="samp">\</samp>&#8217; that have special meanings.  The
second character in the sequence is always an ordinary character when
used on its own.  Here is a table of &#8216;<samp class="samp">\</samp>&#8217; constructs.
</p>
<dl class="table">
<dt><kbd class="kbd">\|</kbd></dt>
<dd><p>specifies an alternative.  Two regular expressions <var class="var">a</var> and <var class="var">b</var>
with &#8216;<samp class="samp">\|</samp>&#8217; in between form an expression that matches some text if
either <var class="var">a</var> matches it or <var class="var">b</var> matches it.  It works by trying to
match <var class="var">a</var>, and if that fails, by trying to match <var class="var">b</var>.
</p>
<p>Thus, &#8216;<samp class="samp">foo\|bar</samp>&#8217; matches either &#8216;<samp class="samp">foo</samp>&#8217; or &#8216;<samp class="samp">bar</samp>&#8217;
but no other string.
</p>
<p>&#8216;<samp class="samp">\|</samp>&#8217; applies to the largest possible surrounding expressions.  Only a
surrounding &#8216;<samp class="samp">\( &#8230; \)</samp>&#8217; grouping can limit the grouping power of
&#8216;<samp class="samp">\|</samp>&#8217;.
</p>
<p>Full backtracking capability exists to handle multiple uses of &#8216;<samp class="samp">\|</samp>&#8217;.
</p>
</dd>
<dt><a class="index-entry-id" id="index-grouping_002c-in-regular-expressions"></a>
<a id="index-sub_002dexpressions_002c-in-regular-expressions"></a><kbd class="kbd">\( &#8230; \)</kbd></dt>
<dd><p>is a grouping construct that serves three purposes:
</p>
<ol class="enumerate">
<li> To enclose a set of &#8216;<samp class="samp">\|</samp>&#8217; alternatives for other operations.
Thus, &#8216;<samp class="samp">\(foo\|bar\)x</samp>&#8217; matches either &#8216;<samp class="samp">foox</samp>&#8217; or &#8216;<samp class="samp">barx</samp>&#8217;.

</li><li> To enclose a complicated expression for the postfix operators &#8216;<samp class="samp">*</samp>&#8217;,
&#8216;<samp class="samp">+</samp>&#8217; and &#8216;<samp class="samp">?</samp>&#8217; to operate on.  Thus, &#8216;<samp class="samp">ba\(na\)*</samp>&#8217; matches
&#8216;<samp class="samp">bananana</samp>&#8217;, etc., with any (zero or more) number of &#8216;<samp class="samp">na</samp>&#8217;
strings.

</li><li> To record a matched substring for future reference.
</li></ol>

<p>This last application is not a consequence of the idea of a
parenthetical grouping; it is a separate feature that is assigned as a
second meaning to the same &#8216;<samp class="samp">\(&#160;&#8230;&#160;\)</samp>&#8217;<!-- /@w --> construct.  In practice
there is usually no conflict between the two meanings; when there is
a conflict, you can use a shy group, described below.
</p>
</dd>
<dt><a id="index-shy-group_002c-in-regexp"></a><kbd class="kbd">\(?: &#8230; \)</kbd></dt>
<dd><p>specifies a <em class="dfn">shy group</em> that does not record the matched substring;
you can&#8217;t refer back to it with &#8216;<samp class="samp">\<var class="var">d</var></samp>&#8217; (see below).  This is
useful in mechanically combining regular expressions, so that you can
add groups for syntactic purposes without interfering with the
numbering of the groups that are meant to be referred to.
</p>
</dd>
<dt><a id="index-back-reference_002c-in-regexp"></a><kbd class="kbd">\<var class="var">d</var></kbd></dt>
<dd><p>matches the same text that matched the <var class="var">d</var>th occurrence of a
&#8216;<samp class="samp">\( &#8230; \)</samp>&#8217; construct.  This is called a <em class="dfn">back
reference</em>.
</p>
<p>After the end of a &#8216;<samp class="samp">\( &#8230; \)</samp>&#8217; construct, the matcher
remembers the beginning and end of the text matched by that construct.
Then, later on in the regular expression, you can use &#8216;<samp class="samp">\</samp>&#8217;
followed by the digit <var class="var">d</var> to mean &#8220;match the same text matched
the <var class="var">d</var>th &#8216;<samp class="samp">\( &#8230; \)</samp>&#8217; construct&#8221;.
</p>
<p>The strings matching the first nine &#8216;<samp class="samp">\( &#8230; \)</samp>&#8217; constructs
appearing in a regular expression are assigned numbers 1 through 9 in
the order that the open-parentheses appear in the regular expression.
So you can use &#8216;<samp class="samp">\1</samp>&#8217; through &#8216;<samp class="samp">\9</samp>&#8217; to refer to the text matched
by the corresponding &#8216;<samp class="samp">\( &#8230; \)</samp>&#8217; constructs.
</p>
<p>For example, &#8216;<samp class="samp">\(.*\)\1</samp>&#8217; matches any newline-free string that is
composed of two identical halves.  The &#8216;<samp class="samp">\(.*\)</samp>&#8217; matches the first
half, which may be anything, but the &#8216;<samp class="samp">\1</samp>&#8217; that follows must match
the same exact text.
</p>
<p>If a particular &#8216;<samp class="samp">\( &#8230; \)</samp>&#8217; construct matches more than once
(which can easily happen if it is followed by &#8216;<samp class="samp">*</samp>&#8217;), only the last
match is recorded.
</p>
</dd>
<dt><kbd class="kbd"><kbd class="kbd">\{<var class="var">m</var>\}</kbd></kbd></dt>
<dd><p>is a postfix operator specifying <var class="var">m</var> repetitions&#8212;that is, the
preceding regular expression must match exactly <var class="var">m</var> times in a
row.  For example, &#8216;<samp class="samp">x\{4\}</samp>&#8217; matches the string &#8216;<samp class="samp">xxxx</samp>&#8217; and
nothing else.
</p>
</dd>
<dt><kbd class="kbd"><kbd class="kbd">\{<var class="var">m</var>,<var class="var">n</var>\}</kbd></kbd></dt>
<dd><p>is a postfix operator specifying between <var class="var">m</var> and <var class="var">n</var>
repetitions&#8212;that is, the preceding regular expression must match at
least <var class="var">m</var> times, but no more than <var class="var">n</var> times.  If <var class="var">n</var> is
omitted, then there is no upper limit, but the preceding regular
expression must match at least <var class="var">m</var> times.<br/> &#8216;<samp class="samp">\{0,1\}</samp>&#8217; is
equivalent to &#8216;<samp class="samp">?</samp>&#8217;. <br/> &#8216;<samp class="samp">\{0,\}</samp>&#8217; is equivalent to
&#8216;<samp class="samp">*</samp>&#8217;. <br/> &#8216;<samp class="samp">\{1,\}</samp>&#8217; is equivalent to &#8216;<samp class="samp">+</samp>&#8217;.
</p>
</dd>
<dt><kbd class="kbd">\`</kbd></dt>
<dd><p>matches the empty string, but only at the beginning of the string or
buffer (or its accessible portion) being matched against.
</p>
</dd>
<dt><kbd class="kbd">\'</kbd></dt>
<dd><p>matches the empty string, but only at the end of the string or buffer
(or its accessible portion) being matched against.
</p>
</dd>
<dt><kbd class="kbd">\=</kbd></dt>
<dd><p>matches the empty string, but only at point.
</p>
</dd>
<dt><kbd class="kbd">\b</kbd></dt>
<dd><p>matches the empty string, but only at the beginning or
end of a word.  Thus, &#8216;<samp class="samp">\bfoo\b</samp>&#8217; matches any occurrence of
&#8216;<samp class="samp">foo</samp>&#8217; as a separate word.  &#8216;<samp class="samp">\bballs?\b</samp>&#8217; matches
&#8216;<samp class="samp">ball</samp>&#8217; or &#8216;<samp class="samp">balls</samp>&#8217; as a separate word.
</p>
<p>&#8216;<samp class="samp">\b</samp>&#8217; matches at the beginning or end of the buffer
regardless of what text appears next to it.
</p>
</dd>
<dt><kbd class="kbd">\B</kbd></dt>
<dd><p>matches the empty string, but <em class="emph">not</em> at the beginning or
end of a word.
</p>
</dd>
<dt><kbd class="kbd">\&lt;</kbd></dt>
<dd><p>matches the empty string, but only at the beginning of a word.
&#8216;<samp class="samp">\&lt;</samp>&#8217; matches at the beginning of the buffer only if a
word-constituent character follows.
</p>
</dd>
<dt><kbd class="kbd">\&gt;</kbd></dt>
<dd><p>matches the empty string, but only at the end of a word.  &#8216;<samp class="samp">\&gt;</samp>&#8217;
matches at the end of the buffer only if the contents end with a
word-constituent character.
</p>
</dd>
<dt><kbd class="kbd">\w</kbd></dt>
<dd><p>matches any word-constituent character.  The syntax table determines
which characters these are.  See <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables">Syntax Tables</a> in <cite class="cite">The Emacs Lisp Reference Manual</cite>.
</p>
</dd>
<dt><kbd class="kbd">\W</kbd></dt>
<dd><p>matches any character that is not a word-constituent.
</p>
</dd>
<dt><kbd class="kbd">\_&lt;</kbd></dt>
<dd><p>matches the empty string, but only at the beginning of a symbol.
A symbol is a sequence of one or more symbol-constituent characters.
A symbol-constituent character is a character whose syntax is either
&#8216;<samp class="samp">w</samp>&#8217; or &#8216;<samp class="samp">_</samp>&#8217;.  &#8216;<samp class="samp">\_&lt;</samp>&#8217; matches at the beginning of the
buffer only if a symbol-constituent character follows.  As with words,
the syntax table determines which characters are symbol-constituent.
</p>
</dd>
<dt><kbd class="kbd">\_&gt;</kbd></dt>
<dd><p>matches the empty string, but only at the end of a symbol.  &#8216;<samp class="samp">\_&gt;</samp>&#8217;
matches at the end of the buffer only if the contents end with a
symbol-constituent character.
</p>
</dd>
<dt><kbd class="kbd">\s<var class="var">c</var></kbd></dt>
<dd><p>matches any character whose syntax is <var class="var">c</var>.  Here <var class="var">c</var> is a
character that designates a particular syntax class: thus, &#8216;<samp class="samp">w</samp>&#8217;
for word constituent, &#8216;<samp class="samp">-</samp>&#8217; or &#8216;<samp class="samp"> </samp>&#8217; for whitespace, &#8216;<samp class="samp">.</samp>&#8217;
for ordinary punctuation, etc.  See <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Class-Table.html#Syntax-Class-Table">Syntax Class Table</a> in <cite class="cite">The Emacs Lisp Reference Manual</cite>.
</p>
</dd>
<dt><kbd class="kbd">\S<var class="var">c</var></kbd></dt>
<dd><p>matches any character whose syntax is not <var class="var">c</var>.
</p>
</dd>
<dt><a class="index-entry-id" id="index-characters-which-belong-to-a-specific-language"></a>
<a class="index-entry-id" id="index-describe_002dcategories"></a>
<a id="index-categories-of-characters"></a><kbd class="kbd">\c<var class="var">c</var></kbd></dt>
<dd><p>matches any character that belongs to the category <var class="var">c</var>.  For
example, &#8216;<samp class="samp">\cc</samp>&#8217; matches Chinese characters, &#8216;<samp class="samp">\cg</samp>&#8217; matches
Greek characters, etc.  For the description of the known categories,
type <kbd class="kbd">M-x describe-categories <kbd class="key">RET</kbd></kbd>.
</p>
</dd>
<dt><kbd class="kbd">\C<var class="var">c</var></kbd></dt>
<dd><p>matches any character that does <em class="emph">not</em> belong to category
<var class="var">c</var>.
</p></dd>
</dl>

<p>The constructs that pertain to words and syntax are controlled by
the setting of the syntax table.  See <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables">Syntax Tables</a> in <cite class="cite">The Emacs Lisp Reference Manual</cite>.
</p>
</div>
<div class="section-level-extent" id="Regexp-Example">
<h3 class="section" id="Regular-Expression-Example">16.8 Regular Expression Example</h3>

<p>Here is an example of a regexp&#8212;similar to the regexp that Emacs
uses, by default, to recognize the end of a sentence, not including
the following space (i.e., the variable <code class="code">sentence-end-base</code>):
</p>
<div class="example">
<pre class="verbatim">[.?!][]\&quot;')}]*
</pre></div>

<p>This contains two parts in succession: a character set matching
period, &#8216;<samp class="samp">?</samp>&#8217;, or &#8216;<samp class="samp">!</samp>&#8217;, and a character set matching
close-brackets, quotes, or parentheses, repeated zero or more times.
</p>
</div>
<div class="section-level-extent" id="Lax-Search">
<h3 class="section" id="Lax-Matching-During-Searching">16.9 Lax Matching During Searching</h3>

<a class="index-entry-id" id="index-lax-search"></a>
<a class="index-entry-id" id="index-character-equivalence-in-search"></a>
<p>Normally, you&#8217;d want search commands to disregard certain minor
differences between the search string you type and the text being
searched.  For example, sequences of whitespace characters of
different length are usually perceived as equivalent; letter-case
differences usually don&#8217;t matter; etc.  This is known as
<em class="dfn">character equivalence</em>.
</p>
<p>This section describes the Emacs lax search features, and how to
tailor them to your needs.
</p>
<a class="index-entry-id" id="index-lax-space-matching-in-search"></a>
<a class="index-entry-id" id="index-M_002ds-SPC-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-SPC-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dtoggle_002dlax_002dwhitespace"></a>
<a class="index-entry-id" id="index-search_002dwhitespace_002dregexp"></a>
<p>By default, search commands perform <em class="dfn">lax space matching</em>: each
space, or sequence of spaces, matches any sequence of one or more
whitespace characters in the text.  More precisely, Emacs matches each
sequence of space characters in the search string to a regular
expression specified by the user option
<code class="code">search-whitespace-regexp</code>.  The default value of this option
considers any sequence of spaces and tab characters as whitespace.
Hence, &#8216;<samp class="samp">foo&#160;bar</samp>&#8217;<!-- /@w --> matches &#8216;<samp class="samp">foo&#160;bar</samp>&#8217;<!-- /@w -->, &#8216;<samp class="samp">foo&#160;&#160;bar</samp>&#8217;<!-- /@w -->, &#8216;<samp class="samp">foo&#160;&#160;&#160;bar</samp>&#8217;<!-- /@w -->, and so on (but not &#8216;<samp class="samp">foobar</samp>&#8217;).  If
you want to make spaces match sequences of newlines as well as spaces
and tabs, customize the option to make its value be the regular
expression &#8216;<samp class="samp">[ \t\n]+</samp>&#8217;.  (The default behavior of the
incremental regexp search is different; see <a class="ref" href="#Regexp-Search">Regular Expression Search</a>.)
</p>
<p>If you want whitespace characters to match exactly, you can turn lax
space matching off by typing <kbd class="kbd">M-s <kbd class="key">SPC</kbd></kbd>
(<code class="code">isearch-toggle-lax-whitespace</code>) within an incremental search.
Another <kbd class="kbd">M-s <kbd class="key">SPC</kbd></kbd> turns lax space matching back on.  To
disable lax whitespace matching for all searches, change
<code class="code">search-whitespace-regexp</code> to <code class="code">nil</code>; then each space in the
search string matches exactly one space.
</p>
<a class="index-entry-id" id="index-case-folding-in-search"></a>
<a class="index-entry-id" id="index-case_002dsensitivity-and-search"></a>
<p>Searches in Emacs by default ignore the case of the text they are
searching through, if you specify the search string in lower case.
Thus, if you specify searching for &#8216;<samp class="samp">foo</samp>&#8217;, then &#8216;<samp class="samp">Foo</samp>&#8217; and
&#8216;<samp class="samp">fOO</samp>&#8217; also match.  Regexps, and in particular character sets,
behave likewise: &#8216;<samp class="samp">[ab]</samp>&#8217; matches &#8216;<samp class="samp">a</samp>&#8217; or &#8216;<samp class="samp">A</samp>&#8217; or &#8216;<samp class="samp">b</samp>&#8217;
or &#8216;<samp class="samp">B</samp>&#8217;.  This feature is known as <em class="dfn">case folding</em>, and it is
supported in both incremental and non-incremental search modes.
</p>
<a class="index-entry-id" id="index-search_002dupper_002dcase"></a>
<p>An upper-case letter anywhere in the search string makes the search
case-sensitive.  Thus, searching for &#8216;<samp class="samp">Foo</samp>&#8217; does not find
&#8216;<samp class="samp">foo</samp>&#8217; or &#8216;<samp class="samp">FOO</samp>&#8217;.  This applies to regular expression search
as well as to literal string search.  The effect ceases if you delete
the upper-case letter from the search string.  The variable
<code class="code">search-upper-case</code> controls this: if it is non-<code class="code">nil</code>, an
upper-case character in the search string makes the search
case-sensitive; setting it to <code class="code">nil</code> disables this effect of
upper-case characters.  The default value of this variable is
<code class="code">not-yanks</code>, which makes search case-sensitive if there are
upper-case letters in the search string, and also causes text yanked
into the search string (see <a class="pxref" href="#Isearch-Yank">Isearch Yanking</a>) to be down-cased, so
that such searches are case-insensitive by default.
</p>
<a class="index-entry-id" id="index-case_002dfold_002dsearch"></a>
<p>If you set the variable <code class="code">case-fold-search</code> to <code class="code">nil</code>, then
all letters must match exactly, including case.  This is a per-buffer
variable; altering the variable normally affects only the current buffer,
unless you change its default value.  See <a class="xref" href="Customization.xhtml#Locals">Local Variables</a>.
This variable applies to nonincremental searches also, including those
performed by the replace commands (see <a class="pxref" href="#Replace">Replacement Commands</a>) and the minibuffer
history matching commands (see <a class="pxref" href="Minibuffer.xhtml#Minibuffer-History">Minibuffer History</a>).
</p>
<a class="index-entry-id" id="index-M_002dc-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-M_002ds-c-_0028Incremental-search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dtoggle_002dcase_002dfold"></a>
<p>Typing <kbd class="kbd">M-c</kbd> or <kbd class="kbd">M-s c</kbd> (<code class="code">isearch-toggle-case-fold</code>)
within an incremental search toggles the case sensitivity of that
search.  The effect does not extend beyond the current incremental
search, but it does override the effect of adding or removing an
upper-case letter in the current search.
</p>
<p>Several related variables control case-sensitivity of searching and
matching for specific commands or activities.  For instance,
<code class="code">tags-case-fold-search</code> controls case sensitivity for
<code class="code">find-tag</code>.  To find these variables, do <kbd class="kbd">M-x
apropos-variable <kbd class="key">RET</kbd> case-fold-search <kbd class="key">RET</kbd></kbd>.
</p>
<a class="index-entry-id" id="index-character-folding-in-search"></a>
<a class="index-entry-id" id="index-equivalent-character-sequences"></a>
<p>Case folding disregards case distinctions among characters, making
upper-case characters match lower-case variants, and vice versa.  A
generalization of case folding is <em class="dfn">character folding</em>, which
disregards wider classes of distinctions among similar characters.
For instance, under character folding the letter <code class="code">a</code> matches all
of its accented cousins like <code class="code">&#228;</code> and <code class="code">&#225;</code>, i.e., the
match disregards the diacritics that distinguish these
variants.  In addition, <code class="code">a</code> matches other characters that
resemble it, or have it as part of their graphical representation,
such as U+00AA <small class="sc">FEMININE ORDINAL INDICATOR</small> and U+24D0
<small class="sc">CIRCLED LATIN SMALL LETTER A</small> (which looks like a small <code class="code">a</code>
inside a circle).
Similarly, the <abbr class="acronym">ASCII</abbr> double-quote character <code class="code">&quot;</code> matches
all the other variants of double quotes defined by the Unicode
standard.  Finally, character folding can make a sequence of one or
more characters match another sequence of a different length: for
example, the sequence of two characters <code class="code">ff</code> matches U+FB00
<small class="sc">LATIN SMALL LIGATURE FF</small> and the sequence <code class="code">(a)</code> matches
U+249C <small class="sc">PARENTHESIZED LATIN SMALL LETTER A</small>.  Character sequences
that are not identical, but match under character folding are known as
<em class="dfn">equivalent character sequences</em>.
</p>
<a class="index-entry-id" id="index-M_002ds-_0027-_0028Incremental-Search_0029"></a>
<a class="index-entry-id" id="index-isearch_002dtoggle_002dchar_002dfold"></a>
<p>Generally, search commands in Emacs do not by default perform
character folding in order to match equivalent character sequences.
You can enable this behavior by customizing the variable
<code class="code">search-default-mode</code> to <code class="code">char-fold-to-regexp</code>.
See <a class="xref" href="#Search-Customizations">Tailoring Search to Your Needs</a>.  Within an incremental search, typing
<kbd class="kbd">M-s '</kbd> (<code class="code">isearch-toggle-char-fold</code>) toggles character
folding, but only for that search.  (Replace commands have a different
default, controlled by a separate option; see <a class="ref" href="#Replacement-and-Lax-Matches">Replace Commands and Lax Matches</a>.)
</p>
<a class="index-entry-id" id="index-char_002dfold_002dsymmetric"></a>
<p>By default, typing an explicit variant of a character, such as
<code class="code">&#228;</code>, as part of the search string doesn&#8217;t match its base
character, such as <code class="code">a</code>.  But if you customize the variable
<code class="code">char-fold-symmetric</code> to <code class="code">t</code>, then search commands treat
equivalent characters the same and use of any of a set of equivalent
characters in a search string finds any of them in the text being
searched, so typing an accented character <code class="code">&#228;</code> matches the
letter <code class="code">a</code> as well as all the other variants like <code class="code">&#225;</code>.
</p>
<a class="index-entry-id" id="index-char_002dfold_002dinclude"></a>
<a class="index-entry-id" id="index-char_002dfold_002dexclude"></a>
<a class="index-entry-id" id="index-char_002dfold_002doverride"></a>
<p>You can add new foldings using the customizable variable
<code class="code">char-fold-include</code>, or remove the existing ones using the
customizable variable <code class="code">char-fold-exclude</code>.  You can also
customize <code class="code">char-fold-override</code> to <code class="code">t</code> to disable all the
character equivalences except those you add yourself using
<code class="code">char-fold-include</code>.
</p>
</div>
<div class="section-level-extent" id="Replace">
<h3 class="section" id="Replacement-Commands">16.10 Replacement Commands</h3>
<a class="index-entry-id" id="index-replacement"></a>
<a class="index-entry-id" id="index-search_002dand_002dreplace-commands"></a>
<a class="index-entry-id" id="index-string-substitution"></a>
<a class="index-entry-id" id="index-global-substitution"></a>

<p>Emacs provides several commands for performing search-and-replace
operations.  In addition to the simple <kbd class="kbd">M-x replace-string</kbd>
command, there is <kbd class="kbd">M-%</kbd> (<code class="code">query-replace</code>), which presents
each occurrence of the search pattern and asks you whether to replace
it.
</p>
<p>The replace commands normally operate on the text from point to the
end of the buffer.  When the region is active, they operate on it
instead (see <a class="pxref" href="Mark.xhtml#Mark">The Mark and the Region</a>).  The basic replace commands replace one
<em class="dfn">search string</em> (or regexp) with one <em class="dfn">replacement string</em>.  It
is possible to perform several replacements in parallel, using the
command <code class="code">expand-region-abbrevs</code> (see <a class="pxref" href="Abbrevs.xhtml#Expanding-Abbrevs">Controlling Abbrev Expansion</a>).
</p>

<div class="subsection-level-extent" id="Unconditional-Replace">
<h4 class="subsection" id="Unconditional-Replacement">16.10.1 Unconditional Replacement</h4>
<a class="index-entry-id" id="index-replace_002dstring"></a>

<dl class="table">
<dt><kbd class="kbd">M-x replace-string <kbd class="key">RET</kbd> <var class="var">string</var> <kbd class="key">RET</kbd> <var class="var">newstring</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Replace every occurrence of <var class="var">string</var> with <var class="var">newstring</var>.
</p></dd>
</dl>

<p>To replace every instance of &#8216;<samp class="samp">foo</samp>&#8217; after point with &#8216;<samp class="samp">bar</samp>&#8217;,
use the command <kbd class="kbd">M-x replace-string</kbd> with the two arguments
&#8216;<samp class="samp">foo</samp>&#8217; and &#8216;<samp class="samp">bar</samp>&#8217;.  Replacement happens only in the text after
point, so if you want to cover the whole buffer you must go to the
beginning first.  All occurrences up to the end of the buffer are
replaced; to limit replacement to part of the buffer, activate the
region around that part.  When the region is active, replacement is
limited to the region (see <a class="pxref" href="Mark.xhtml#Mark">The Mark and the Region</a>).
</p>
<p>When <code class="code">replace-string</code> exits, it leaves point at the last
occurrence replaced.  It adds the prior position of point (where the
<code class="code">replace-string</code> command was issued) to the mark ring, without
activating the mark; use <kbd class="kbd">C-u C-<kbd class="key">SPC</kbd></kbd> to move back there.
See <a class="xref" href="Mark.xhtml#Mark-Ring">The Mark Ring</a>.
</p>
<p>A prefix argument restricts replacement to matches that are
surrounded by word boundaries.
</p>
<p>See <a class="xref" href="#Replacement-and-Lax-Matches">Replace Commands and Lax Matches</a>, for details about
case-sensitivity and character folding in replace commands.
</p>
</div>
<div class="subsection-level-extent" id="Regexp-Replace">
<h4 class="subsection" id="Regexp-Replacement">16.10.2 Regexp Replacement</h4>
<a class="index-entry-id" id="index-replace_002dregexp"></a>

<p>The <kbd class="kbd">M-x replace-string</kbd> command replaces exact matches for a
single string.  The similar command <kbd class="kbd">M-x replace-regexp</kbd> replaces
any match for a specified regular expression pattern (see <a class="pxref" href="#Regexps">Syntax of Regular Expressions</a>).
</p>
<dl class="table">
<dt><kbd class="kbd">M-x replace-regexp <kbd class="key">RET</kbd> <var class="var">regexp</var> <kbd class="key">RET</kbd> <var class="var">newstring</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Replace every match for <var class="var">regexp</var> with <var class="var">newstring</var>.
</p></dd>
</dl>

<a class="index-entry-id" id="index-back-reference_002c-in-regexp-replacement"></a>
<p>In <code class="code">replace-regexp</code>, the <var class="var">newstring</var> need not be constant:
it can refer to all or part of what is matched by the <var class="var">regexp</var>.
&#8216;<samp class="samp">\&amp;</samp>&#8217; in <var class="var">newstring</var> stands for the entire match being
replaced.  &#8216;<samp class="samp">\<var class="var">d</var></samp>&#8217; in <var class="var">newstring</var>, where <var class="var">d</var> is a
digit starting from 1, stands for whatever matched the <var class="var">d</var>th
parenthesized grouping in <var class="var">regexp</var>.  (This is called a &#8220;back
reference&#8221;.)  &#8216;<samp class="samp">\#</samp>&#8217; refers to the count of replacements already
made in this command, as a decimal number.  In the first replacement,
&#8216;<samp class="samp">\#</samp>&#8217; stands for &#8216;<samp class="samp">0</samp>&#8217;; in the second, for &#8216;<samp class="samp">1</samp>&#8217;; and so on.
For example,
</p>
<div class="example">
<pre class="example-preformatted">M-x replace-regexp <kbd class="key">RET</kbd> c[ad]+r <kbd class="key">RET</kbd> \&amp;-safe <kbd class="key">RET</kbd>
</pre></div>

<p>replaces (for example) &#8216;<samp class="samp">cadr</samp>&#8217; with &#8216;<samp class="samp">cadr-safe</samp>&#8217; and &#8216;<samp class="samp">cddr</samp>&#8217;
with &#8216;<samp class="samp">cddr-safe</samp>&#8217;.
</p>
<div class="example">
<pre class="example-preformatted">M-x replace-regexp <kbd class="key">RET</kbd> \(c[ad]+r\)-safe <kbd class="key">RET</kbd> \1 <kbd class="key">RET</kbd>
</pre></div>

<p>performs the inverse transformation.  To include a &#8216;<samp class="samp">\</samp>&#8217; in the
text to replace with, you must enter &#8216;<samp class="samp">\\</samp>&#8217;.
</p>
<p>If you want to enter part of the replacement string by hand each
time, use &#8216;<samp class="samp">\?</samp>&#8217; in the replacement string.  Each replacement will
ask you to edit the replacement string in the minibuffer, putting
point where the &#8216;<samp class="samp">\?</samp>&#8217; was.
</p>
<p>The remainder of this subsection is intended for specialized tasks
and requires knowledge of Lisp.  Most readers can skip it.
</p>
<p>You can use Lisp expressions to calculate parts of the
replacement string.  To do this, write &#8216;<samp class="samp">\,</samp>&#8217; followed by the
expression in the replacement string.  Each replacement calculates the
value of the expression and converts it to text without quoting (if
it&#8217;s a string, this means using the string&#8217;s contents), and uses it in
the replacement string in place of the expression itself.  If the
expression is a symbol, one space in the replacement string after the
symbol name goes with the symbol name, so the value replaces them
both.
</p>
<p>Inside such an expression, you can use some special sequences.
&#8216;<samp class="samp">\&amp;</samp>&#8217; and &#8216;<samp class="samp">\<var class="var">d</var></samp>&#8217; refer here, as usual, to the entire
match as a string, and to a submatch as a string.  <var class="var">d</var> may be
multiple digits, and the value of &#8216;<samp class="samp">\<var class="var">d</var></samp>&#8217; is <code class="code">nil</code> if the
<var class="var">d</var>&#8217;th parenthesized grouping did not match.  You can also use
&#8216;<samp class="samp">\#&amp;</samp>&#8217; and &#8216;<samp class="samp">\#<var class="var">d</var></samp>&#8217; to refer to those matches as numbers
(this is valid when the match or submatch has the form of a numeral).
&#8216;<samp class="samp">\#</samp>&#8217; here too stands for the number of already-completed
replacements.
</p>
<p>For example, we can exchange &#8216;<samp class="samp">x</samp>&#8217; and &#8216;<samp class="samp">y</samp>&#8217; this way:
</p>
<div class="example">
<pre class="example-preformatted">M-x replace-regexp <kbd class="key">RET</kbd> \(x\)\|y <kbd class="key">RET</kbd>
\,(if \1 &quot;y&quot; &quot;x&quot;) <kbd class="key">RET</kbd>
</pre></div>

<p>For computing replacement strings for &#8216;<samp class="samp">\,</samp>&#8217;, the <code class="code">format</code>
function is often useful (see <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Formatting-Strings.html#Formatting-Strings">Formatting Strings</a> in <cite class="cite">The Emacs
Lisp Reference Manual</cite>).  For example, to add consecutively numbered
strings like &#8216;<samp class="samp">ABC00042</samp>&#8217; to columns 73 to&#160;80<!-- /@w --> (unless they are
already occupied), you can use
</p>
<div class="example">
<pre class="example-preformatted">M-x replace-regexp <kbd class="key">RET</kbd> ^.\{0,72\}$ <kbd class="key">RET</kbd>
\,(format &quot;%-72sABC%05d&quot; \&amp; \#) <kbd class="key">RET</kbd>
</pre></div>

</div>
<div class="subsection-level-extent" id="Replacement-and-Lax-Matches">
<h4 class="subsection" id="Replace-Commands-and-Lax-Matches">16.10.3 Replace Commands and Lax Matches</h4>

<p>This subsection describes the behavior of replace commands with
respect to lax matches (see <a class="pxref" href="#Lax-Search">Lax Matching During Searching</a>) and how to customize it.
In general, replace commands mostly default to stricter matching than
their search counterparts.
</p>
<a class="index-entry-id" id="index-lax-space-matching-in-replace-commands"></a>
<a class="index-entry-id" id="index-replace_002dlax_002dwhitespace"></a>
<p>Unlike incremental search, the replacement commands do not use lax
space matching (see <a class="pxref" href="#Lax-Search">lax space matching</a>) by default.
To enable lax space matching for replacement, change the variable
<code class="code">replace-lax-whitespace</code> to non-<code class="code">nil</code>.  (This only affects
how Emacs finds the text to replace, not the replacement text.)
</p>
<a class="index-entry-id" id="index-replace_002dregexp_002dlax_002dwhitespace"></a>
<p>A companion variable <code class="code">replace-regexp-lax-whitespace</code> controls
whether <code class="code">query-replace-regexp</code> uses lax whitespace matching when
searching for patterns.
</p>
<a class="index-entry-id" id="index-case-folding-in-replace-commands"></a>
<p>If the first argument of a replace command is all lower case, the
command ignores case while searching for occurrences to
replace&#8212;provided <code class="code">case-fold-search</code> is non-<code class="code">nil</code> and
<code class="code">search-upper-case</code> is also non-<code class="code">nil</code>.  If
<code class="code">search-upper-case</code> (see <a class="pxref" href="#Lax-Search">search-upper-case</a>) is
<code class="code">nil</code>, whether searching ignores case is determined by
<code class="code">case-fold-search</code> alone, regardless of letter-case of the
command&#8217;s first argument.  If <code class="code">case-fold-search</code> is set to
<code class="code">nil</code>, case is always significant in all searches.
</p>
<a class="index-entry-id" id="index-case_002dreplace"></a>
<a class="index-entry-id" id="index-case-preservation-in-replace-commands"></a>
<p>In addition, when the second argument of a replace command is all or
partly lower case, replacement commands try to preserve the case
pattern of each occurrence.  Thus, the command
</p>
<div class="example">
<pre class="example-preformatted">M-x replace-string <kbd class="key">RET</kbd> foo <kbd class="key">RET</kbd> bar <kbd class="key">RET</kbd>
</pre></div>

<p>replaces a lower case &#8216;<samp class="samp">foo</samp>&#8217; with a lower case &#8216;<samp class="samp">bar</samp>&#8217;, an
all-caps &#8216;<samp class="samp">FOO</samp>&#8217; with &#8216;<samp class="samp">BAR</samp>&#8217;, and a capitalized &#8216;<samp class="samp">Foo</samp>&#8217; with
&#8216;<samp class="samp">Bar</samp>&#8217;.  (These three alternatives&#8212;lower case, all caps, and
capitalized, are the only ones that <code class="code">replace-string</code> can
distinguish.)  Note that Emacs decides whether to up-case or capitalize
the replacement text by analyzing each word in the text being
replaced, and will preserve the letter-case of the replaced text only
if <em class="emph">all</em> of its words use the same letter-case.  Thus, the
command
</p>
<div class="example">
<pre class="example-preformatted">M-x replace-string <kbd class="key">RET</kbd> foo bar <kbd class="key">RET</kbd> baz quux <kbd class="key">RET</kbd>
</pre></div>

<p>replaces &#8216;<samp class="samp">Foo Bar</samp>&#8217; with &#8216;<samp class="samp">Baz Quux</samp>&#8217; because both words in
&#8216;<samp class="samp">Foo Bar</samp>&#8217; are capitalized.  By contrast, the same command
replaces &#8216;<samp class="samp">Foo bar</samp>&#8217; with &#8216;<samp class="samp">baz quux</samp>&#8217;, i.e. it leaves the
letter-case of the replacement text unchanged, since the two words in
&#8216;<samp class="samp">Foo bar</samp>&#8217; use different capitalization.  What exactly is
considered a &#8220;word&#8221; depends on the syntax tables that are in effect
in the current buffer (see <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables">Syntax Tables</a> in <cite class="cite">The Emacs Lisp
Reference Manual</cite>); thus, &#8216;<samp class="samp">Foo_Bar</samp>&#8217; is two words in Text mode,
but could be a single word in some major mode that supports a
programming language.
</p>
<p>If upper-case letters are used in the replacement string, they remain
upper case every time that text is inserted.  If upper-case letters are
used in the first argument, the second argument is always substituted
exactly as given, with no case conversion.  Likewise, if either
<code class="code">case-replace</code> or <code class="code">case-fold-search</code> is set to <code class="code">nil</code>,
replacement is done without case conversion.
</p>
<a class="index-entry-id" id="index-character-folding-in-replace-commands"></a>
<p>The replacement commands by default do not use character folding
(see <a class="pxref" href="#Lax-Search">character folding</a>) when looking for the text to
replace.  To enable character folding for matching in
<code class="code">query-replace</code> and <code class="code">replace-string</code>, set the variable
<code class="code">replace-char-fold</code> to a non-<code class="code">nil</code> value.  (This
setting does not affect the replacement text, only how Emacs finds the
text to replace.  It also doesn&#8217;t affect <code class="code">replace-regexp</code>.)
</p>
</div>
<div class="subsection-level-extent" id="Query-Replace">
<h4 class="subsection" id="Query-Replace-1">16.10.4 Query Replace</h4>
<a class="index-entry-id" id="index-query-replace"></a>

<dl class="table">
<dt><kbd class="kbd">M-% <var class="var">string</var> <kbd class="key">RET</kbd> <var class="var">newstring</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Replace some occurrences of <var class="var">string</var> with <var class="var">newstring</var>.
</p></dd>
<dt><kbd class="kbd">C-M-% <var class="var">regexp</var> <kbd class="key">RET</kbd> <var class="var">newstring</var> <kbd class="key">RET</kbd></kbd></dt>
<dd><p>Replace some matches for <var class="var">regexp</var> with <var class="var">newstring</var>.
</p></dd>
</dl>

<a class="index-entry-id" id="index-M_002d_0025"></a>
<a class="index-entry-id" id="index-query_002dreplace"></a>
<p>If you want to change only some of the occurrences of &#8216;<samp class="samp">foo</samp>&#8217; to
&#8216;<samp class="samp">bar</samp>&#8217;, not all of them, use <kbd class="kbd">M-%</kbd> (<code class="code">query-replace</code>).
This command finds occurrences of &#8216;<samp class="samp">foo</samp>&#8217; one by one, displays each
occurrence and asks you whether to replace it.  Aside from querying,
<code class="code">query-replace</code> works just like <code class="code">replace-string</code>
(see <a class="pxref" href="#Unconditional-Replace">Unconditional Replacement</a>).  In particular, it preserves case
provided that <code class="code">case-replace</code> is non-<code class="code">nil</code>, as it normally is
(see <a class="pxref" href="#Replacement-and-Lax-Matches">Replace Commands and Lax Matches</a>).  A numeric argument means to
consider only occurrences that are bounded by word-delimiter
characters.  A negative prefix argument replaces backward.
</p>
<a class="index-entry-id" id="index-C_002dM_002d_0025"></a>
<a class="index-entry-id" id="index-query_002dreplace_002dregexp"></a>
<p><kbd class="kbd">C-M-%</kbd> performs regexp search and replace (<code class="code">query-replace-regexp</code>).
It works like <code class="code">replace-regexp</code> except that it queries
like <code class="code">query-replace</code>.
</p>
<a class="index-entry-id" id="index-query_002dreplace_002dfrom_002dto_002dseparator"></a>
<p>You can reuse earlier replacements with these commands.  When
<code class="code">query-replace</code> or <code class="code">query-replace-regexp</code> prompts for the
search string, use <kbd class="kbd">M-p</kbd> and <kbd class="kbd">M-n</kbd> to show previous
replacements in the form &#8216;<samp class="samp"><var class="var">from</var> -&gt; <var class="var">to</var></samp>&#8217;, where
<var class="var">from</var> is the search pattern, <var class="var">to</var> is its replacement, and the
separator between them is determined by the value of the variable
<code class="code">query-replace-from-to-separator</code>.  Type <kbd class="key">RET</kbd> to select the
desired replacement.  If the value of this variable is <code class="code">nil</code>,
replacements are not added to the command history, and cannot be
reused.
</p>
<a class="index-entry-id" id="index-faces-for-highlighting-query-replace"></a>
<a class="index-entry-id" id="index-query_002dreplace-face"></a>
<a class="index-entry-id" id="index-lazy_002dhighlight-face_002c-in-replace"></a>
<a class="index-entry-id" id="index-query_002dreplace_002dhighlight"></a>
<a class="index-entry-id" id="index-query_002dreplace_002dhighlight_002dsubmatches"></a>
<a class="index-entry-id" id="index-query_002dreplace_002dlazy_002dhighlight"></a>
<a class="index-entry-id" id="index-query_002dreplace_002dshow_002dreplacement"></a>
<p>These commands highlight the current match using the face
<code class="code">query-replace</code>.  You can disable this highlight by setting the
variable <code class="code">query-replace-highlight</code> to <code class="code">nil</code>.  They highlight
other matches using <code class="code">lazy-highlight</code> just like incremental search
(see <a class="pxref" href="#Incremental-Search">Incremental Search</a>); this can be disabled by setting
<code class="code">query-replace-lazy-highlight</code> to <code class="code">nil</code>.  By default,
<code class="code">query-replace-regexp</code> will show the substituted replacement
string for the current match in the minibuffer.  If you want to keep
special sequences &#8216;<samp class="samp">\&amp;</samp>&#8217; and &#8216;<samp class="samp">\<var class="var">n</var></samp>&#8217; unexpanded, customize
<code class="code">query-replace-show-replacement</code> variable.
Like <code class="code">search-highlight-submatches</code> highlights subexpressions in
incremental search (see <a class="pxref" href="#Search-Customizations">Tailoring Search to Your Needs</a>), the variable
<code class="code">query-replace-highlight-submatches</code> defines whether to highlight
subexpressions in the regexp replacement commands.
</p>
<a class="index-entry-id" id="index-query_002dreplace_002dskip_002dread_002donly"></a>
<p>The variable <code class="code">query-replace-skip-read-only</code>, if set
non-<code class="code">nil</code>, will cause replacement commands to ignore matches in
read-only text.  The default is not to ignore them.
</p>
<p>The characters you can type when you are shown a match for the string
or regexp are:
</p>

<dl class="table">
<dt><kbd class="kbd"><kbd class="key">SPC</kbd></kbd></dt>
<dt><kbd class="kbd">y</kbd></dt>
<dd><p>to replace the occurrence with <var class="var">newstring</var>.
</p>
</dd>
<dt><kbd class="kbd"><kbd class="key">DEL</kbd></kbd></dt>
<dt><kbd class="kbd"><kbd class="key">Delete</kbd></kbd></dt>
<dt><kbd class="kbd"><kbd class="key">BACKSPACE</kbd></kbd></dt>
<dt><kbd class="kbd">n</kbd></dt>
<dd><p>to skip to the next occurrence without replacing this one.
</p>
</dd>
<dt><kbd class="kbd">, <span class="r">(Comma)</span></kbd></dt>
<dd><p>to replace this occurrence and display the result.  You are then asked
for another input character to say what to do next.  Since the
replacement has already been made, <kbd class="key">DEL</kbd> and <kbd class="key">SPC</kbd> are
equivalent in this situation; both move to the next occurrence.
</p>
<p>You can type <kbd class="kbd">C-r</kbd> at this point (see below) to alter the replaced
text.  You can also undo the replacement with the <code class="code">undo</code> command
(e.g., type <kbd class="kbd">C-x u</kbd>; see <a class="pxref" href="Fixit.xhtml#Undo">Undo</a>); this exits the
<code class="code">query-replace</code>, so if you want to do further replacement you
must use <kbd class="kbd">C-x <kbd class="key">ESC</kbd> <kbd class="key">ESC</kbd> <kbd class="key">RET</kbd></kbd> to restart
(see <a class="pxref" href="Minibuffer.xhtml#Repetition">Repeating Minibuffer Commands</a>).
</p>
</dd>
<dt><kbd class="kbd"><kbd class="key">RET</kbd></kbd></dt>
<dt><kbd class="kbd">q</kbd></dt>
<dd><p>to exit without doing any more replacements.
</p>
</dd>
<dt><kbd class="kbd">. <span class="r">(Period)</span></kbd></dt>
<dd><p>to replace this occurrence and then exit without searching for more
occurrences.
</p>
</dd>
<dt><kbd class="kbd">!</kbd></dt>
<dd><p>to replace all remaining occurrences without asking again.
</p>
</dd>
<dt><kbd class="kbd">^</kbd></dt>
<dd><p>to go back to the position of the previous occurrence (or what used to
be an occurrence), in case you changed it by mistake or want to
reexamine it.
</p>
</dd>
<dt><kbd class="kbd">u</kbd></dt>
<dd><p>to undo the last replacement and go back to where that replacement was
made.
</p>
</dd>
<dt><kbd class="kbd">U</kbd></dt>
<dd><p>to undo all the replacements and go back to where the first
replacement was made.
</p>
</dd>
<dt><kbd class="kbd">C-r</kbd></dt>
<dd><p>to enter a recursive editing level, in case the occurrence needs to be
edited rather than just replaced with <var class="var">newstring</var>.  When you are
done, exit the recursive editing level with <kbd class="kbd">C-M-c</kbd> to proceed to
the next occurrence.  See <a class="xref" href="Recursive-Edit.xhtml">Recursive Editing Levels</a>.
</p>
</dd>
<dt><kbd class="kbd">C-w</kbd></dt>
<dd><p>to delete the occurrence, and then enter a recursive editing level as in
<kbd class="kbd">C-r</kbd>.  Use the recursive edit to insert text to replace the deleted
occurrence of <var class="var">string</var>.  When done, exit the recursive editing level
with <kbd class="kbd">C-M-c</kbd> to proceed to the next occurrence.
</p>
</dd>
<dt><kbd class="kbd">e</kbd></dt>
<dd><p>to edit the replacement string in the minibuffer.  When you exit the
minibuffer by typing <kbd class="key">RET</kbd>, the minibuffer contents replace the
current occurrence of the pattern.  They also become the new
replacement string for any further occurrences.
</p>
</dd>
<dt><kbd class="kbd">E</kbd></dt>
<dd><p>is like <kbd class="kbd">e</kbd>, but the next replacement will be done with exact
case.  I.e., if you have a <code class="code">query-replace</code> from &#8216;<samp class="samp">foo</samp>&#8217; to
&#8216;<samp class="samp">bar</samp>&#8217;, a text like &#8216;<samp class="samp">Foo</samp>&#8217; will be normally be replaced with
&#8216;<samp class="samp">Bar</samp>&#8217;.  Use this command to do the current replacement with exact
case.
</p>
</dd>
<dt><kbd class="kbd">C-l</kbd></dt>
<dd><p>to redisplay the screen.  Then you must type another character to
specify what to do with this occurrence.
</p>
</dd>
<dt><kbd class="kbd">Y <span class="r">(Upper-case)</span></kbd></dt>
<dd><p>to replace all remaining occurrences in all remaining buffers in
multi-buffer replacements (like the Dired <kbd class="kbd">Q</kbd> command that performs
query replace on selected files).  It answers this question and all
subsequent questions in the series with &#8220;yes&#8221;, without further
user interaction.
</p>
</dd>
<dt><kbd class="kbd">N <span class="r">(Upper-case)</span></kbd></dt>
<dd><p>to skip to the next buffer in multi-buffer replacements without
replacing remaining occurrences in the current buffer.  It answers
this question &#8220;no&#8221;, gives up on the questions for the current buffer,
and continues to the next buffer in the sequence.
</p>
</dd>
<dt><kbd class="kbd">C-h</kbd></dt>
<dt><kbd class="kbd">?</kbd></dt>
<dt><kbd class="kbd"><kbd class="key">F1</kbd></kbd></dt>
<dd><p>to display a message summarizing these options.  Then you must type
another character to specify what to do with this occurrence.
</p></dd>
</dl>

<p>Aside from this, any other character exits the <code class="code">query-replace</code>,
and is then reread as part of a key sequence.  Thus, if you type
<kbd class="kbd">C-k</kbd>, it exits the <code class="code">query-replace</code> and then kills to end of
line.  In particular, <kbd class="kbd">C-g</kbd> simply exits the <code class="code">query-replace</code>.
</p>
<p>To restart a <code class="code">query-replace</code> once it is exited, use <kbd class="kbd">C-x
<kbd class="key">ESC</kbd> <kbd class="key">ESC</kbd></kbd>, which repeats the <code class="code">query-replace</code> because it
used the minibuffer to read its arguments.  See <a class="xref" href="Minibuffer.xhtml#Repetition">C-x <kbd class="key">ESC</kbd>
<kbd class="key">ESC</kbd></a>.
</p>
<a class="index-entry-id" id="index-invisible-text_002c-and-query_002dreplace"></a>
<p>The option <code class="code">search-invisible</code> determines how <code class="code">query-replace</code>
treats invisible text.  See <a class="xref" href="Text.xhtml#Outline-Search">Outline Search</a>.
</p>
<p>See <a class="xref" href="Dired.xhtml#Operating-on-Files">Operating on Files</a>, for the Dired <kbd class="kbd">Q</kbd> command which
performs query replace on selected files.  See also <a class="ref" href="Dired.xhtml#Transforming-File-Names">Transforming File Names in Dired</a>, for Dired commands to rename, copy, or link files by
replacing regexp matches in file names.
</p>
</div>
</div>
<div class="section-level-extent" id="Other-Repeating-Search">
<h3 class="section" id="Other-Search_002dand_002dLoop-Commands">16.11 Other Search-and-Loop Commands</h3>

<p>Here are some other commands that find matches for regular
expressions.  They all ignore case in matching, if the pattern contains
no upper-case letters and <code class="code">case-fold-search</code> is non-<code class="code">nil</code>.
Aside from <code class="code">multi-occur</code> and <code class="code">multi-occur-in-matching-buffers</code>,
which always search the whole buffer, all of the commands operate on the
text from point to the end of the buffer, or on the region if it is active.
</p>
<dl class="table">
<dt><a class="index-entry-id" id="index-isearch-multiple-buffers"></a>
<a class="index-entry-id" id="index-multiple_002dbuffer-isearch"></a>
<a id="index-multi_002disearch_002dbuffers"></a><kbd class="kbd">M-x multi-isearch-buffers</kbd></dt>
<dd><p>Prompt for one or more buffer names, ending with <kbd class="key">RET</kbd>; then,
begin a multi-buffer incremental search in those buffers.  (If the
search fails in one buffer, the next <kbd class="kbd">C-s</kbd> tries searching the
next specified buffer, and so forth.)  With a prefix argument, prompt
for a regexp and begin a multi-buffer incremental search in buffers
matching that regexp.
</p>
</dd>
<dt><a id="index-multi_002disearch_002dbuffers_002dregexp"></a><kbd class="kbd">M-x multi-isearch-buffers-regexp</kbd></dt>
<dd><p>This command is just like <code class="code">multi-isearch-buffers</code>, except it
performs an incremental regexp search.
</p>
</dd>
<dt><a class="index-entry-id" id="index-isearch-multiple-files"></a>
<a class="index-entry-id" id="index-multiple_002dfile-isearch"></a>
<a id="index-multi_002disearch_002dfiles"></a><kbd class="kbd">M-x multi-isearch-files</kbd></dt>
<dd><p>Prompt for one or more file names, ending with <kbd class="key">RET</kbd>; then,
begin a multi-file incremental search in those files.  (If the
search fails in one file, the next <kbd class="kbd">C-s</kbd> tries searching the
next specified file, and so forth.)  With a prefix argument, prompt
for a regexp and begin a multi-file incremental search in files
matching that regexp.
</p>
</dd>
<dt><a id="index-multi_002disearch_002dfiles_002dregexp"></a><kbd class="kbd">M-x multi-isearch-files-regexp</kbd></dt>
<dd><p>This command is just like <code class="code">multi-isearch-files</code>, except it
performs an incremental regexp search.
</p>
<p>In some modes that set the buffer-local variable
<code class="code">multi-isearch-next-buffer-function</code> (e.g., in Change Log mode)
a multi-file incremental search is activated automatically.
</p>
<a class="index-entry-id" id="index-Occur-mode"></a>
<a class="index-entry-id" id="index-mode_002c-Occur"></a>
<a class="index-entry-id" id="index-match-_0028face-name_0029"></a>
<a class="index-entry-id" id="index-list_002dmatching_002dlines_002ddefault_002dcontext_002dlines"></a>
<a class="index-entry-id" id="index-list_002dmatching_002dlines_002djump_002dto_002dcurrent_002dline"></a>
</dd>
<dt><a class="index-entry-id" id="index-occur"></a>
<a id="index-M_002ds-o"></a><kbd class="kbd">M-x occur</kbd></dt>
<dt><kbd class="kbd">M-s o</kbd></dt>
<dd><p>Prompt for a regexp, and display a list showing each line in the
buffer that contains a match for it.  If you type <kbd class="kbd">M-n</kbd> at the
prompt, you can reuse search strings from previous incremental
searches.  The text that matched is highlighted using the <code class="code">match</code>
face.  A numeric argument <var class="var">n</var> specifies that <var class="var">n</var> lines of
context are to be displayed before and after each matching line.
</p>
<p>The default number of context lines is specified by the variable
<code class="code">list-matching-lines-default-context-lines</code>.  When
<code class="code">list-matching-lines-jump-to-current-line</code> is non-<code class="code">nil</code> the
current line is shown highlighted with face
<code class="code">list-matching-lines-current-line-face</code> and the point is set at
the first match after such line.
</p>
<p>You can also run <kbd class="kbd">M-s o</kbd> when an incremental search is active;
this uses the current search string.
</p>
<p>Note that matches for the regexp you type are extended to include
complete lines, and a match that starts before the previous match ends
is not considered a match.
</p>
<a class="index-entry-id" id="index-RET-_0028Occur-mode_0029"></a>
<a class="index-entry-id" id="index-o-_0028Occur-mode_0029"></a>
<a class="index-entry-id" id="index-C_002do-_0028Occur-mode_0029"></a>
<p>The <samp class="file">*Occur*</samp> buffer uses the Occur mode as its major mode.  You
can use the <kbd class="kbd">n</kbd> and <kbd class="kbd">p</kbd> keys to move to the next or previous
match; with prefix numeric argument, these commands move that many
matches.  Digit keys are bound to <code class="code">digit-argument</code>, so <kbd class="kbd">5 n</kbd>
moves to the fifth next match (you don&#8217;t have to type <kbd class="kbd">C-u</kbd>).
<kbd class="key">SPC</kbd> and <kbd class="key">DEL</kbd> scroll the <samp class="file">*Occur*</samp> buffer up and down.
Clicking on a match or moving point there and typing <kbd class="key">RET</kbd> visits
the corresponding position in the original buffer that was searched.
<kbd class="kbd">o</kbd> and <kbd class="kbd">C-o</kbd> display the match in another window; <kbd class="kbd">C-o</kbd>
does not select that window.  Alternatively, you can use the <kbd class="kbd">M-g
M-n</kbd> (<code class="code">next-error</code>) command to visit the occurrences one by one
(see <a class="pxref" href="Building.xhtml#Compilation-Mode">Compilation Mode</a>).  Finally, <kbd class="kbd">q</kbd> quits the window showing
the <samp class="file">*Occur*</samp> buffer and buries the buffer.
</p>
<a class="index-entry-id" id="index-Occur-Edit-mode"></a>
<a class="index-entry-id" id="index-mode_002c-Occur-Edit"></a>
<p>Typing <kbd class="kbd">e</kbd> in the <samp class="file">*Occur*</samp> buffer makes the buffer writable
and enters the Occur Edit mode, in which you can edit the matching
lines and have those edits reflected in the text in the originating
buffer.  Type <kbd class="kbd">C-c C-c</kbd> to leave the Occur Edit mode and return to
the Occur mode.
</p>
<a class="index-entry-id" id="index-list_002dmatching_002dlines"></a>
<p>The command <kbd class="kbd">M-x list-matching-lines</kbd> is a synonym for <kbd class="kbd">M-x
occur</kbd>.
</p>
</dd>
<dt><a id="index-multi_002doccur"></a><kbd class="kbd">M-x multi-occur</kbd></dt>
<dd><p>This command is just like <code class="code">occur</code>, except it is able to search
through multiple buffers.  It asks you to specify the buffer names one
by one.
</p>
</dd>
<dt><a id="index-multi_002doccur_002din_002dmatching_002dbuffers"></a><kbd class="kbd">M-x multi-occur-in-matching-buffers</kbd></dt>
<dd><p>This command is similar to <code class="code">multi-occur</code>, except the buffers to
search are specified by a regular expression that matches visited file
names.  With a prefix argument, it uses the regular expression to
match buffer names instead.
</p>
</dd>
<dt><a id="index-how_002dmany"></a><kbd class="kbd">M-x how-many</kbd></dt>
<dd><p>Prompt for a regexp, and print the number of matches for it in the
buffer after point.  If the region is active, this operates on the
region instead.
</p>
</dd>
<dt><a id="index-flush_002dlines"></a><kbd class="kbd">M-x flush-lines</kbd></dt>
<dd><p>Prompt for a regexp, and delete each line that contains a match for
it, operating on the text after point.  When the command finishes,
it prints the number of deleted matching lines.
</p>
<p>This command deletes the current line if it contains a match starting
after point.  If the region is active, it operates on the region
instead; if a line partially contained in the region contains a match
entirely contained in the region, it is deleted.
</p>
<p>If a match is split across lines, <code class="code">flush-lines</code> deletes all those
lines.  It deletes the lines before starting to look for the next
match; hence, it ignores a match starting on the same line at which
another match ended.
</p>
</dd>
<dt><a id="index-keep_002dlines"></a><kbd class="kbd">M-x keep-lines</kbd></dt>
<dd><p>Prompt for a regexp, and delete each line that <em class="emph">does not</em> contain
a match for it, operating on the text after point.  If point is not at
the beginning of a line, this command always keeps the current line.
If the region is active, the command operates on the region instead;
it never deletes lines that are only partially contained in the region
(a newline that ends a line counts as part of that line).
</p>
<p>If a match is split across lines, this command keeps all those lines.
</p>
</dd>
<dt><a id="index-kill_002dmatching_002dlines"></a><kbd class="kbd">M-x kill-matching-lines</kbd></dt>
<dd><p>Like <code class="code">flush-lines</code>, but also add the matching lines to the kill
ring.  The command adds the matching lines to the kill ring as a
single string, including the newlines that separated the lines.
</p>
</dd>
<dt><a id="index-copy_002dmatching_002dlines"></a><kbd class="kbd">M-x copy-matching-lines</kbd></dt>
<dd><p>Like <code class="code">kill-matching-lines</code>, but the matching lines are not
removed from the buffer.
</p></dd>
</dl>

</div>
<div class="section-level-extent" id="Search-Customizations">
<h3 class="section" id="Tailoring-Search-to-Your-Needs">16.12 Tailoring Search to Your Needs</h3>
<a class="index-entry-id" id="index-search-customizations"></a>

<p>This section describes miscellaneous search-related customizations
not described elsewhere.
</p>
<a class="index-entry-id" id="index-default-search-mode"></a>
<a class="index-entry-id" id="index-search-mode_002c-default"></a>
<p>The default search mode for the incremental search is specified by
the variable <code class="code">search-default-mode</code>.  It can be <code class="code">nil</code>,
<code class="code">t</code>, or a function.  If it is <code class="code">nil</code>, the default mode is to
do literal searches without character folding, but with case folding
and lax-whitespace matches as determined by <code class="code">case-fold-search</code>
and <code class="code">search-whitespace-regexp</code>, respectively (see <a class="pxref" href="#Lax-Search">Lax Matching During Searching</a>).  If the value is <code class="code">t</code>, incremental search defaults to
regexp searches.  The default value specifies a function that only
performs case folding and lax-whitespace matching.
</p>
<a class="index-entry-id" id="index-search_002dhighlight"></a>
<p>The current match of an on-going incremental search is highlighted
using the <code class="code">isearch</code> face.  This highlighting can be disabled by
setting the variable <code class="code">search-highlight</code> to <code class="code">nil</code>.
</p>
<a class="index-entry-id" id="index-search_002dhighlight_002dsubmatches"></a>
<p>When searching for regular expressions (with <kbd class="kbd">C-M-s</kbd>, for
instance), subexpressions receive special highlighting depending on
the <code class="code">search-highlight-submatches</code> variable.  If this variable&#8217;s
value is <code class="code">nil</code>, no special highlighting is done, but if the value
is non-<code class="code">nil</code>, text that matches &#8216;<samp class="samp">\( &#8230; \)</samp>&#8217; constructs
(a.k.a. &#8220;subexpressions&#8221;) in the regular expression will be
highlighted with distinct faces.  By default, two distinct faces are
defined, named <code class="code">isearch-group-1</code> and <code class="code">isearch-group-2</code>.
With these two faces, odd-numbered subexpressions will be highlighted
using the <code class="code">isearch-group-1</code> face and even-numbered subexpressions
will be highlighted using the <code class="code">isearch-group-2</code> face.  For
instance, when searching for &#8216;<samp class="samp">foo-\([0-9]+\)\([a-z]+\)</samp>&#8217;, the part
matched by &#8216;<samp class="samp">[0-9]+</samp>&#8217; will be highlighted with the
<code class="code">isearch-group-1</code> face, and the part matched by &#8216;<samp class="samp">[a-z]+</samp>&#8217;
will be highlighted using <code class="code">isearch-group-2</code>.  If you define
additional faces using the same numbering scheme, i.e.
<code class="code">isearch-group-3</code>, <code class="code">isearch-group-4</code>, &#8230;, then the face
<code class="code">isearch-group-<var class="var">M</var></code> will be used to highlight the <var class="var">M</var>&#8217;th,
<code class="code"><var class="var">N</var>+<var class="var">M</var></code>&#8217;th, <code class="code">2<var class="var">N</var>+<var class="var">M</var></code>&#8217;th, &#8230;
subexpressions, where <var class="var">N</var> is the total number of faces of the form
<code class="code">isearch-group-<var class="var">M</var></code>.
</p>
<a class="index-entry-id" id="index-lazy-highlighting-customizations"></a>
<a class="index-entry-id" id="index-isearch_002dlazy_002dhighlight"></a>
<a class="index-entry-id" id="index-lazy_002dhighlight-face"></a>
<p>The other matches for the search string that are visible on display
are highlighted using the <code class="code">lazy-highlight</code> face.  Setting the
variable <code class="code">isearch-lazy-highlight</code> to <code class="code">nil</code> disables this
highlighting.  Here are some other variables that customize the lazy
highlighting:
</p>
<dl class="table">
<dt><a id="index-lazy_002dhighlight_002dinitial_002ddelay"></a><code class="code">lazy-highlight-initial-delay</code></dt>
<dd><p>Time in seconds to wait before highlighting visible matches.
Applies only if the search string is less than
<code class="code">lazy-highlight-no-delay-length</code> characters long.
</p>
</dd>
<dt><a id="index-lazy_002dhighlight_002dno_002ddelay_002dlength"></a><code class="code">lazy-highlight-no-delay-length</code></dt>
<dd><p>For search strings at least as long as the value of this variable,
lazy highlighting of matches starts immediately.
</p>
</dd>
<dt><a id="index-lazy_002dhighlight_002dinterval"></a><code class="code">lazy-highlight-interval</code></dt>
<dd><p>Time in seconds between highlighting successive matches.
</p>
</dd>
<dt><a id="index-lazy_002dhighlight_002dmax_002dat_002da_002dtime"></a><code class="code">lazy-highlight-max-at-a-time</code></dt>
<dd><p>The maximum number of matches to highlight before checking for input.
A large number can take some time to highlight, so if you want to
continue searching and type <kbd class="kbd">C-s</kbd> or <kbd class="kbd">C-r</kbd> during that time,
Emacs will not respond until it finishes highlighting all those
matches.  Thus, smaller values make Emacs more responsive.
</p>
</dd>
<dt><a id="index-isearch_002dlazy_002dcount"></a><code class="code">isearch-lazy-count</code></dt>
<dd><p>Show the current match number and the total number of matches in the
search prompt.
</p>
</dd>
<dt><a class="index-entry-id" id="index-lazy_002dcount_002dsuffix_002dformat"></a>
<a id="index-lazy_002dcount_002dprefix_002dformat"></a><code class="code">lazy-count-prefix-format</code></dt>
<dt><code class="code">lazy-count-suffix-format</code></dt>
<dd><p>These two variables determine the format of showing the current and
the total number of matches for <code class="code">isearch-lazy-count</code>.
</p></dd>
</dl>

<a class="index-entry-id" id="index-search_002dnonincremental_002dinstead"></a>
<p>Normally, entering <kbd class="key">RET</kbd> within incremental search when the
search string is empty launches a nonincremental search.  (Actually,
it lets you edit the search string, and the next <kbd class="key">RET</kbd> does the
search.)  However, if you customize the variable
<code class="code">search-nonincremental-instead</code> to <code class="code">nil</code>, typing <kbd class="key">RET</kbd>
will always exit the incremental search, even if the search string is
empty.
</p>
<a class="index-entry-id" id="index-isearch_002dhide_002dimmediately"></a>
<p>By default, incremental search and query-replace commands match
invisible text, but hide any such matches as soon as the current match
moves off the invisible text.  If you customize the variable
<code class="code">isearch-hide-immediately</code> to <code class="code">nil</code>, any invisible text
where matches were found stays on display until the search or the
replace command exits.
</p>
<a class="index-entry-id" id="index-search-display-on-slow-terminals"></a>
<a class="index-entry-id" id="index-search_002dslow_002dspeed"></a>
<a class="index-entry-id" id="index-search_002dslow_002dwindow_002dlines"></a>
<p>Searching incrementally on slow terminals, such as displays
connected to remote machines over slow connection, could be annoying
due to the need to redraw large portions of the display as the search
proceeds.  Emacs provides a special display mode for slow terminals,
whereby search pops up a separate small window and displays the text
surrounding the match in that window.  Small windows display faster,
so the annoying effect of slow speed is alleviated.  The variable
<code class="code">search-slow-speed</code> determines the baud rate threshold below
which Emacs will use this display mode.  The variable
<code class="code">search-slow-window-lines</code> controls the number of lines in the
window Emacs pops up for displaying the search results; the default is
1 line.  Normally, this window will pop up at the bottom of the window
that displays the buffer where you start searching, but if the value
of <code class="code">search-slow-window-lines</code> is negative, that means to put the
window at the top and give it the number of lines that is the absolute
value of <code class="code">search-slow-window-lines</code>.
</p></div>
</div>



</body>
</html>
