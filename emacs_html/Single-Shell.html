<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- 这是 GNU Emacs 手册,
为 Emacs  29.2 更新

英文原版版权提示 - Original English version copyright note

Copyright © 1985-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "The GNU Manifesto," "Distribution" and
"GNU GENERAL PUBLIC LICENSE," with the Front-Cover Texts being "A GNU
Manual," and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."

中文翻译版版权提示 - Chinese translation revision copyright notice

版权所有 © 1985-2024 林羿轩(Ralph Lin).

您有在 Free Software Foundation发布的GNU Free Documentation License 第1.3版或之后版本的约束下对其进行再发布及修的权利。 恒定章节为 "The GNU Manifesto," "分发" "(中文版)GNU GENERAL PUBLIC LICENSE" 和
"GNU GENERAL PUBLIC LICENSE" , 前封面文字为 "A GNU
Manual,"后封面文字如下(a).  本书的FDL许可证可以在 "GNU Free Documentation
License."找到.

(a) FSF的后封面文字为: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."
 -->
<title>Single Shell (GNU Emacs Manual)</title>

<meta name="description" content="Single Shell (GNU Emacs Manual)">
<meta name="keywords" content="Single Shell (GNU Emacs Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Key-Index.html" rel="index" title="Key Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Shell.html" rel="up" title="Shell">
<link href="Interactive-Shell.html" rel="next" title="Interactive Shell">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
kbd.kbd {font-style: oblique}
kbd.key {font-style: normal}
span:hover a.copiable-link {visibility: visible}
-->
</style>


</head>

<body lang="zh_CN">
<div class="subsection-level-extent" id="Single-Shell">
<div class="nav-panel">
<p>
Next: <a href="Interactive-Shell.html" accesskey="n" rel="next">Interactive Subshell</a>, Up: <a href="Shell.html" accesskey="u" rel="up">Running Shell Commands from Emacs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Key-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Single-Shell-Commands"><span>35.5.1 Single Shell Commands<a class="copiable-link" href="#Single-Shell-Commands"> &para;</a></span></h4>

<a class="index-entry-id" id="index-M_002d_0021"></a>
<a class="index-entry-id" id="index-shell_002dcommand"></a>
<a class="index-entry-id" id="index-shell_002dcommand_002dbuffer_002dname"></a>
<p><kbd class="kbd">M-!</kbd> (<code class="code">shell-command</code>) reads a line of text using the
minibuffer and executes it as a shell command, in a subshell made just
for that command.  Standard input for the command comes from the null
device.  If the shell command produces any output, the output appears
either in the echo area (if it is short), or in the &lsquo;<samp class="samp">&quot;*Shell
Command Output*&quot;</samp>&rsquo; (<code class="code">shell-command-buffer-name</code>) buffer (if the
output is long).  The variables <code class="code">resize-mini-windows</code> and
<code class="code">max-mini-window-height</code> (see <a class="pxref" href="Minibuffer-Edit.html">Editing in the Minibuffer</a>) control when
Emacs should consider the output to be too long for the echo area.
Note that customizing <code class="code">shell-command-dont-erase-buffer</code>,
described below, can affect what is displayed in the echo area.
</p>
<p>For instance, one way to decompress a file named <samp class="file">foo.gz</samp> is to
type <kbd class="kbd">M-! gunzip foo.gz <kbd class="key">RET</kbd></kbd>.  That shell command normally
creates the file <samp class="file">foo</samp> and produces no terminal output.
</p>
<p>A numeric argument to <code class="code">shell-command</code>, e.g., <kbd class="kbd">M-1 M-!</kbd>,
causes it to insert terminal output into the current buffer instead of
a separate buffer.  By default, it puts point before the output, and
sets the mark after the output (but a non-default value of
<code class="code">shell-command-dont-erase-buffer</code> can change that, see below).
For instance, <kbd class="kbd">M-1 M-! gunzip &lt; foo.gz <kbd class="key">RET</kbd></kbd> would insert the
uncompressed form of the file <samp class="file">foo.gz</samp> into the current buffer.
</p>
<p>Provided the specified shell command does not end with &lsquo;<samp class="samp">&amp;</samp>&rsquo;, it
runs <em class="dfn">synchronously</em>, and you must wait for it to exit before
continuing to use Emacs.  To stop waiting, type <kbd class="kbd">C-g</kbd> to quit;
this sends a <code class="code">SIGINT</code> signal to terminate the shell command (this
is the same signal that <kbd class="kbd">C-c</kbd> normally generates in the shell).
Emacs then waits until the command actually terminates.  If the shell
command doesn&rsquo;t stop (because it ignores the <code class="code">SIGINT</code> signal),
type <kbd class="kbd">C-g</kbd> again; this sends the command a <code class="code">SIGKILL</code> signal,
which is impossible to ignore.
</p>
<a class="index-entry-id" id="index-M_002d_0026"></a>
<a class="index-entry-id" id="index-async_002dshell_002dcommand"></a>
<a class="index-entry-id" id="index-shell_002dcommand_002dbuffer_002dname_002dasync"></a>
<p>A shell command that ends in &lsquo;<samp class="samp">&amp;</samp>&rsquo; is executed
<em class="dfn">asynchronously</em>, and you can continue to use Emacs as it runs.
You can also type <kbd class="kbd">M-&amp;</kbd> (<code class="code">async-shell-command</code>) to execute a
shell command asynchronously; this is exactly like calling <kbd class="kbd">M-!</kbd>
with a trailing &lsquo;<samp class="samp">&amp;</samp>&rsquo;, except that you do not need the &lsquo;<samp class="samp">&amp;</samp>&rsquo;.
The output from asynchronous shell commands, by default, goes into the
&lsquo;<samp class="samp">&quot;*Async Shell Command*&quot;</samp>&rsquo; buffer
(<code class="code">shell-command-buffer-name-async</code>).  Emacs inserts the output
into this buffer as it comes in, whether or not the buffer is visible
in a window.
</p>
<a class="index-entry-id" id="index-async_002dshell_002dcommand_002dbuffer"></a>
<p>If you want to run more than one asynchronous shell command at the
same time, they could end up competing for the output buffer.  The
option <code class="code">async-shell-command-buffer</code> specifies what to do about
this; e.g., whether to rename the pre-existing output buffer, or to
use a different buffer for the new command.  Consult the variable&rsquo;s
documentation for more possibilities.
</p>
<a class="index-entry-id" id="index-async_002dshell_002dcommand_002ddisplay_002dbuffer"></a>
<p>If you want the output buffer for asynchronous shell commands to be
displayed only when the command generates output, set
<code class="code">async-shell-command-display-buffer</code> to <code class="code">nil</code>.
</p>
<a class="index-entry-id" id="index-async_002dshell_002dcommand_002dwidth"></a>
<p>The option <code class="code">async-shell-command-width</code> defines the number of display
columns available for output of asynchronous shell commands.
A positive integer tells the shell to use that number of columns for
command output.  The default value is <code class="code">nil</code> that means to use
the same number of columns as provided by the shell.
</p>
<a class="index-entry-id" id="index-shell_002dcommand_002dprompt_002dshow_002dcwd"></a>
<p>To make the above commands show the current directory in their
prompts, customize the variable <code class="code">shell-command-prompt-show-cwd</code>
to a non-<code class="code">nil</code> value.
</p>
<a class="index-entry-id" id="index-M_002d_007c"></a>
<a class="index-entry-id" id="index-shell_002dcommand_002don_002dregion"></a>
<p><kbd class="kbd">M-|</kbd> (<code class="code">shell-command-on-region</code>) is like <kbd class="kbd">M-!</kbd>, but
passes the contents of the region as the standard input to the shell
command, instead of no input.  With a numeric argument, it deletes the
old region and replaces it with the output from the shell command.
</p>
<p>For example, you can use <kbd class="kbd">M-|</kbd> with the <code class="command">gpg</code> program to
see what keys are in the buffer.  If the buffer contains a GnuPG key,
type <kbd class="kbd">C-x h M-| gpg <kbd class="key">RET</kbd></kbd> to feed the entire buffer contents
to <code class="command">gpg</code>.  This will output the list of keys to the
buffer whose name is the value of <code class="code">shell-command-buffer-name</code>.
</p>
<a class="index-entry-id" id="index-shell_002dfile_002dname"></a>
<a class="index-entry-id" id="index-SHELL-environment-variable"></a>
<p>The above commands use the shell specified by the variable
<code class="code">shell-file-name</code>.  Its default value is determined by the
<code class="env">SHELL</code> environment variable when Emacs is started.  If the file
name is relative, Emacs searches the directories listed in
<code class="code">exec-path</code> (see <a class="pxref" href="Shell.html">Running Shell Commands from Emacs</a>).
</p>
<p>If the default directory is remote (see <a class="pxref" href="Remote-Files.html">Remote Files</a>), the
default value is <samp class="file">/bin/sh</samp>.  This can be changed by declaring
<code class="code">shell-file-name</code> connection-local (see <a class="pxref" href="Connection-Variables.html">Per-Connection Local Variables</a>).
</p>
<p>To specify a coding system for <kbd class="kbd">M-!</kbd> or <kbd class="kbd">M-|</kbd>, use the command
<kbd class="kbd">C-x <kbd class="key">RET</kbd> c</kbd> immediately beforehand.  See <a class="xref" href="Communication-Coding.html">Coding Systems for Interprocess Communication</a>.
</p>
<a class="index-entry-id" id="index-shell_002dcommand_002ddefault_002derror_002dbuffer"></a>
<p>By default, error output is intermixed with the regular output in
the output buffer.  But if you change the value of the variable
<code class="code">shell-command-default-error-buffer</code> to a string, error output is
inserted into a buffer of that name.
</p>
<a class="index-entry-id" id="index-shell_002dcommand_002ddont_002derase_002dbuffer"></a>
<p>By default, the output buffer is erased between shell commands, except
when the output goes to the current buffer.  If you change the value
of the option <code class="code">shell-command-dont-erase-buffer</code> to <code class="code">erase</code>,
then the output buffer is always erased.  Other non-<code class="code">nil</code> values
prevent erasing of the output buffer, and&mdash;if the output buffer is
not the current buffer&mdash;also control where to put point after
inserting the output of the shell command:
</p>
<dl class="table">
<dt><code class="code">beg-last-out</code></dt>
<dd><p>Puts point at the beginning of the last shell-command output.
</p></dd>
<dt><code class="code">end-last-out</code></dt>
<dd><p>Puts point at the end of the last shell-command output, i.e. at the
end of the output buffer.
</p></dd>
<dt><code class="code">save-point</code></dt>
<dd><p>Restores the position of point as it was before inserting the
shell-command output.
</p></dd>
</dl>

<p>Note that if this option is non-<code class="code">nil</code>, the output shown in the
echo area could be from more than just the last command, since the
echo area just displays a portion of the output buffer.
</p>
<p>In case the output buffer is not the current buffer, shell command
output is appended at the end of this buffer.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Interactive-Shell.html">Interactive Subshell</a>, Up: <a href="Shell.html">Running Shell Commands from Emacs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Key-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
