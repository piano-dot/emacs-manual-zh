<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- 这是 GNU Emacs 手册,
为 Emacs  29.2 更新

英文原版版权提示 - Original English version copyright note

Copyright © 1985-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "The GNU Manifesto," "Distribution" and
"GNU GENERAL PUBLIC LICENSE," with the Front-Cover Texts being "A GNU
Manual," and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."

中文翻译版版权提示 - Chinese translation revision copyright notice

版权所有 © 1985-2024 林羿轩(Ralph Lin).

您有在 Free Software Foundation发布的GNU Free Documentation License 第1.3版或之后版本的约束下对其进行再发布及修的权利。 恒定章节为 "The GNU Manifesto," "分发" "(中文版)GNU GENERAL PUBLIC LICENSE" 和
"GNU GENERAL PUBLIC LICENSE" , 前封面文字为 "A GNU
Manual,"后封面文字如下(a).  本书的FDL许可证可以在 "GNU Free Documentation
License."找到.

(a) FSF的后封面文字为: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."
 -->
<title>Shell Mode (GNU Emacs Manual)</title>

<meta name="description" content="Shell Mode (GNU Emacs Manual)">
<meta name="keywords" content="Shell Mode (GNU Emacs Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Key-Index.html" rel="index" title="Key Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Shell.html" rel="up" title="Shell">
<link href="Shell-Prompts.html" rel="next" title="Shell Prompts">
<link href="Interactive-Shell.html" rel="prev" title="Interactive Shell">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
kbd.key {font-style: normal}
span:hover a.copiable-link {visibility: visible}
-->
</style>


</head>

<body lang="zh_CN">
<div class="subsection-level-extent" id="Shell-Mode">
<div class="nav-panel">
<p>
Next: <a href="Shell-Prompts.html" accesskey="n" rel="next">Shell Prompts</a>, Previous: <a href="Interactive-Shell.html" accesskey="p" rel="prev">Interactive Subshell</a>, Up: <a href="Shell.html" accesskey="u" rel="up">Running Shell Commands from Emacs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Key-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Shell-Mode-1"><span>35.5.3 Shell Mode<a class="copiable-link" href="#Shell-Mode-1"> &para;</a></span></h4>
<a class="index-entry-id" id="index-Shell-mode"></a>
<a class="index-entry-id" id="index-mode_002c-Shell"></a>

<p>The major mode for Shell buffers is Shell mode.  Many of its special
commands are bound to the <kbd class="kbd">C-c</kbd> prefix, and resemble the usual
editing and job control characters present in ordinary shells, except
that you must type <kbd class="kbd">C-c</kbd> first.  Here is a list of Shell mode
commands:
</p>
<dl class="table">
<dt><a class="index-entry-id" id="index-comint_002dsend_002dinput"></a>
<a id="index-RET-_0028Shell-mode_0029"></a><span><kbd class="kbd"><kbd class="key">RET</kbd></kbd><a class="copiable-link" href="#index-RET-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Send the current line as input to the subshell
(<code class="code">comint-send-input</code>).  Any shell prompt at the beginning of the
line is omitted (see <a class="pxref" href="Shell-Prompts.html">Shell Prompts</a>).  If point is at the end of
buffer, this is like submitting the command line in an ordinary
interactive shell.  However, you can also invoke <kbd class="key">RET</kbd> elsewhere
in the shell buffer to submit the current line as input.
</p>
</dd>
<dt><a class="index-entry-id" id="index-completion_002dat_002dpoint_002c-in-Shell-Mode"></a>
<a class="index-entry-id" id="index-shell-completion"></a>
<a id="index-TAB-_0028Shell-mode_0029"></a><span><kbd class="kbd"><kbd class="key">TAB</kbd></kbd><a class="copiable-link" href="#index-TAB-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Complete the command name or file name before point in the shell
buffer (<code class="code">completion-at-point</code>).  This uses the usual Emacs
completion rules (see <a class="pxref" href="Completion.html">Completion</a>), with the completion
alternatives being file names, environment variable names, the shell
command history, and history references (see <a class="pxref" href="History-References.html">Shell History References</a>).
For options controlling the completion, see <a class="pxref" href="Shell-Options.html">Shell Mode Options</a>.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002ddynamic_002dlist_002dfilename_2026"></a>
<a id="index-M_002d_003f-_0028Shell-mode_0029"></a><span><kbd class="kbd">M-?</kbd><a class="copiable-link" href="#index-M_002d_003f-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Display temporarily a list of the possible completions of the file
name before point (<code class="code">comint-dynamic-list-filename-completions</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002ddelchar_002dor_002dmaybe_002deof"></a>
<a id="index-C_002dd-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-d</kbd><a class="copiable-link" href="#index-C_002dd-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Either delete a character or send <abbr class="acronym">EOF</abbr>
(<code class="code">comint-delchar-or-maybe-eof</code>).  Typed at the end of the shell
buffer, this sends <abbr class="acronym">EOF</abbr> to the subshell.  Typed at any other
position in the buffer, this deletes a character as usual.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dbol_002dor_002dprocess_002dmark"></a>
<a id="index-C_002dc-C_002da-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-c C-a</kbd><a class="copiable-link" href="#index-C_002dc-C_002da-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Move to the beginning of the line, but after the prompt if any
(<code class="code">comint-bol-or-process-mark</code>).  If you repeat this command twice
in a row, the second time it moves back to the process mark, which is
the beginning of the input that you have not yet sent to the subshell.
(Normally that is the same place&mdash;the end of the prompt on this
line&mdash;but after <kbd class="kbd">C-c <kbd class="key">SPC</kbd></kbd> the process mark may be in a
previous line.)
</p>
</dd>
<dt><kbd class="kbd">C-c <kbd class="key">SPC</kbd></kbd></dt>
<dd><p>Accumulate multiple lines of input, then send them together
(<code class="code">comint-accumulate</code>).  This command inserts a newline before
point, but does not send the preceding text as input to the
subshell&mdash;at least, not yet.  Both lines, the one before this newline
and the one after, will be sent together (along with the newline that
separates them), when you type <kbd class="key">RET</kbd>.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dkill_002dinput"></a>
<a id="index-C_002dc-C_002du-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-c C-u</kbd><a class="copiable-link" href="#index-C_002dc-C_002du-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Kill all text pending at end of buffer to be sent as input
(<code class="code">comint-kill-input</code>).  If point is not at end of buffer,
this only kills the part of this text that precedes point.
</p>
</dd>
<dt><a id="index-C_002dc-C_002dw-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-c C-w</kbd><a class="copiable-link" href="#index-C_002dc-C_002dw-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Kill a word before point (<code class="code">backward-kill-word</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dinterrupt_002dsubjob"></a>
<a id="index-C_002dc-C_002dc-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-c C-c</kbd><a class="copiable-link" href="#index-C_002dc-C_002dc-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Interrupt the shell or its current subjob if any
(<code class="code">comint-interrupt-subjob</code>).  This command also kills
any shell input pending in the shell buffer and not yet sent.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dstop_002dsubjob"></a>
<a id="index-C_002dc-C_002dz-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-c C-z</kbd><a class="copiable-link" href="#index-C_002dc-C_002dz-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Stop the shell or its current subjob if any (<code class="code">comint-stop-subjob</code>).
This command also kills any shell input pending in the shell buffer and
not yet sent.
</p>
</dd>
<dt><a class="index-entry-id" id="index-C_002dc-C_002d_005c-_0028Shell-mode_0029"></a>
<a id="index-comint_002dquit_002dsubjob"></a><span><kbd class="kbd">C-c C-\</kbd><a class="copiable-link" href="#index-comint_002dquit_002dsubjob"> &para;</a></span></dt>
<dd><p>Send quit signal to the shell or its current subjob if any
(<code class="code">comint-quit-subjob</code>).  This command also kills any shell input
pending in the shell buffer and not yet sent.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002ddelete_002doutput"></a>
<a id="index-C_002dc-C_002do-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-c C-o</kbd><a class="copiable-link" href="#index-C_002dc-C_002do-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Delete the last batch of output from a shell command
(<code class="code">comint-delete-output</code>).  This is useful if a shell command spews
out lots of output that just gets in the way.  With a prefix argument,
this command saves the deleted text in the <code class="code">kill-ring</code>
(see <a class="pxref" href="Kill-Ring.html">The Kill Ring</a>), so that you could later yank it (see <a class="pxref" href="Yanking.html">Yanking</a>)
elsewhere.
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dwrite_002doutput"></a>
<a id="index-C_002dc-C_002ds-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-c C-s</kbd><a class="copiable-link" href="#index-C_002dc-C_002ds-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Write the last batch of output from a shell command to a file
(<code class="code">comint-write-output</code>).  With a prefix argument, the file is
appended to instead.  Any prompt at the end of the output is not
written.
</p>
</dd>
<dt><a class="index-entry-id" id="index-C_002dM_002dl-_0028Shell-mode_0029"></a>
<a class="index-entry-id" id="index-comint_002dshow_002doutput"></a>
<a id="index-C_002dc-C_002dr-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-c C-r</kbd><a class="copiable-link" href="#index-C_002dc-C_002dr-_0028Shell-mode_0029"> &para;</a></span></dt>
<dt><kbd class="kbd">C-M-l</kbd></dt>
<dd><p>Scroll to display the beginning of the last batch of output at the top
of the window; also move the cursor there (<code class="code">comint-show-output</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-comint_002dshow_002dmaximum_002doutput"></a>
<a id="index-C_002dc-C_002de-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-c C-e</kbd><a class="copiable-link" href="#index-C_002dc-C_002de-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Scroll to put the last line of the buffer at the bottom of the window
(<code class="code">comint-show-maximum-output</code>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-shell_002dforward_002dcommand"></a>
<a class="index-entry-id" id="index-shell_002dcommand_002dregexp"></a>
<a id="index-C_002dc-C_002df-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-c C-f</kbd><a class="copiable-link" href="#index-C_002dc-C_002df-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Move forward across one shell command, but not beyond the current line
(<code class="code">shell-forward-command</code>).  The variable <code class="code">shell-command-regexp</code>
specifies how to recognize the end of a command.
</p>
</dd>
<dt><a class="index-entry-id" id="index-shell_002dbackward_002dcommand"></a>
<a id="index-C_002dc-C_002db-_0028Shell-mode_0029"></a><span><kbd class="kbd">C-c C-b</kbd><a class="copiable-link" href="#index-C_002dc-C_002db-_0028Shell-mode_0029"> &para;</a></span></dt>
<dd><p>Move backward across one shell command, but not beyond the current line
(<code class="code">shell-backward-command</code>).
</p>
</dd>
<dt><kbd class="kbd">M-x dirs</kbd></dt>
<dd><p>Ask the shell for its working directory, and update the Shell buffer&rsquo;s
default directory.  See <a class="xref" href="Directory-Tracking.html">Directory Tracking</a>.
</p>
</dd>
<dt><a id="index-comint_002dsend_002dinvisible"></a><span><kbd class="kbd">M-x comint-send-invisible <kbd class="key">RET</kbd> <var class="var">text</var> <kbd class="key">RET</kbd></kbd><a class="copiable-link" href="#index-comint_002dsend_002dinvisible"> &para;</a></span></dt>
<dd><p>Send <var class="var">text</var> as input to the shell, after reading it without
echoing.  This is useful when a shell command runs a program that asks
for a password.
</p>
<p>Please note that Emacs will not echo passwords by default.  If you
really want them to be echoed, evaluate (see <a class="pxref" href="Lisp-Eval.html">Evaluating Emacs Lisp Expressions</a>) the
following Lisp expression:
</p>
<div class="example">
<pre class="example-preformatted">(remove-hook 'comint-output-filter-functions
             'comint-watch-for-password-prompt)
</pre></div>

</dd>
<dt><a id="index-comint_002dcontinue_002dsubjob"></a><span><kbd class="kbd">M-x comint-continue-subjob</kbd><a class="copiable-link" href="#index-comint_002dcontinue_002dsubjob"> &para;</a></span></dt>
<dd><p>Continue the shell process.  This is useful if you accidentally suspend
the shell process.<a class="footnote" id="DOCF21" href="#FOOT21"><sup>21</sup></a>
</p>
</dd>
<dt><a id="index-comint_002dstrip_002dctrl_002dm"></a><span><kbd class="kbd">M-x comint-strip-ctrl-m</kbd><a class="copiable-link" href="#index-comint_002dstrip_002dctrl_002dm"> &para;</a></span></dt>
<dd><p>Discard all control-M characters from the current group of shell output.
The most convenient way to use this command is to make it run
automatically when you get output from the subshell.  To do that,
evaluate this Lisp expression:
</p>
<div class="example">
<pre class="example-preformatted">(add-hook 'comint-output-filter-functions
          'comint-strip-ctrl-m)
</pre></div>

</dd>
<dt><a id="index-comint_002dtruncate_002dbuffer"></a><span><kbd class="kbd">M-x comint-truncate-buffer</kbd><a class="copiable-link" href="#index-comint_002dtruncate_002dbuffer"> &para;</a></span></dt>
<dd><p>This command truncates the shell buffer to a certain maximum number of
lines, specified by the variable <code class="code">comint-buffer-maximum-size</code>.
Here&rsquo;s how to do this automatically each time you get output from the
subshell:
</p>
<div class="example">
<pre class="example-preformatted">(add-hook 'comint-output-filter-functions
          'comint-truncate-buffer)
</pre></div>
</dd>
</dl>

<p>By default, Shell mode handles common <abbr class="acronym">ANSI</abbr> escape codes (for
instance, for changing the color of text).  Emacs also optionally
supports some extend escape codes, like some of the <abbr class="acronym">OSC</abbr>
(Operating System Codes) if you put the following in your init file:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(add-hook 'comint-output-filter-functions 'comint-osc-process-output)
</pre></div>

<p>With this enabled, the output from, for instance, <code class="code">ls
--hyperlink</code> will be made into clickable buttons in the Shell mode
buffer.
</p>
<a class="index-entry-id" id="index-Comint-mode"></a>
<a class="index-entry-id" id="index-mode_002c-Comint"></a>
<p>Shell mode is a derivative of Comint mode, a general-purpose mode for
communicating with interactive subprocesses.  Most of the features of
Shell mode actually come from Comint mode, as you can see from the
command names listed above.  The special features of Shell mode include
the directory tracking feature, and a few user commands.
</p>
<p>Other Emacs features that use variants of Comint mode include GUD
(see <a class="pxref" href="Debuggers.html">Running Debuggers Under Emacs</a>) and <kbd class="kbd">M-x run-lisp</kbd> (see <a class="pxref" href="External-Lisp.html">Running an External Lisp</a>).
</p>
<a class="index-entry-id" id="index-comint_002drun"></a>
<p>You can use <kbd class="kbd">M-x comint-run</kbd> to execute any program of your choice
in a subprocess using unmodified Comint mode&mdash;without the
specializations of Shell mode.  To pass arguments to the program, use
<kbd class="kbd">C-u M-x comint-run</kbd>.
</p>
</div>
<div class="footnotes-segment">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT21" href="#DOCF21">(21)</a></h5>
<p>You should not suspend the shell process.
Suspending a subjob of the shell is a completely different matter&mdash;that
is normal practice, but you must use the shell to continue the subjob;
this command won&rsquo;t do it.</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Shell-Prompts.html">Shell Prompts</a>, Previous: <a href="Interactive-Shell.html">Interactive Subshell</a>, Up: <a href="Shell.html">Running Shell Commands from Emacs</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Key-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
